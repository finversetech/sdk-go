/*
Finverse Public

Documentation of the early finverse services

API version: 0.0.1
Contact: info@finverse.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package finverse

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type DefaultAPI interface {

	/*
		CancelPaymentLink Method for CancelPaymentLink

		Cancel a payment link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param paymentLinkId The payment link id
		@return DefaultAPICancelPaymentLinkRequest
	*/
	CancelPaymentLink(ctx context.Context, paymentLinkId string) DefaultAPICancelPaymentLinkRequest

	// CancelPaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	CancelPaymentLinkExecute(r DefaultAPICancelPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		CancelPayout Method for CancelPayout

		Cancel Payout by payout_id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param payoutId payout id
		@return DefaultAPICancelPayoutRequest
	*/
	CancelPayout(ctx context.Context, payoutId string) DefaultAPICancelPayoutRequest

	// CancelPayoutExecute executes the request
	//  @return PayoutSnapshotResponse
	CancelPayoutExecute(r DefaultAPICancelPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		ChangePaymentMethodPaymentLink Method for ChangePaymentMethodPaymentLink

		Initiate change payment method from payment link front-end

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIChangePaymentMethodPaymentLinkRequest
	*/
	ChangePaymentMethodPaymentLink(ctx context.Context) DefaultAPIChangePaymentMethodPaymentLinkRequest

	// ChangePaymentMethodPaymentLinkExecute executes the request
	//  @return ChangePaymentMethodFvLinkResponse
	ChangePaymentMethodPaymentLinkExecute(r DefaultAPIChangePaymentMethodPaymentLinkRequest) (*ChangePaymentMethodFvLinkResponse, *http.Response, error)

	/*
		CompleteKcpPayment Method for CompleteKcpPayment

		Complete a KCP payment

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICompleteKcpPaymentRequest
	*/
	CompleteKcpPayment(ctx context.Context) DefaultAPICompleteKcpPaymentRequest

	// CompleteKcpPaymentExecute executes the request
	//  @return CompleteKcpPaymentResponse
	CompleteKcpPaymentExecute(r DefaultAPICompleteKcpPaymentRequest) (*CompleteKcpPaymentResponse, *http.Response, error)

	/*
		ConfirmManualPayment Method for ConfirmManualPayment

		Submit manual payment confirmation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIConfirmManualPaymentRequest
	*/
	ConfirmManualPayment(ctx context.Context) DefaultAPIConfirmManualPaymentRequest

	// ConfirmManualPaymentExecute executes the request
	//  @return ManualPaymentConfirmationResponse
	ConfirmManualPaymentExecute(r DefaultAPIConfirmManualPaymentRequest) (*ManualPaymentConfirmationResponse, *http.Response, error)

	/*
		ConfirmPayment Method for ConfirmPayment

		Confirm a payment against a payment Link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIConfirmPaymentRequest
	*/
	ConfirmPayment(ctx context.Context) DefaultAPIConfirmPaymentRequest

	// ConfirmPaymentExecute executes the request
	//  @return ConfirmPaymentResponse
	ConfirmPaymentExecute(r DefaultAPIConfirmPaymentRequest) (*ConfirmPaymentResponse, *http.Response, error)

	/*
		CreateFpsToken Method for CreateFpsToken

		Create token for fps flow

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICreateFpsTokenRequest
	*/
	CreateFpsToken(ctx context.Context) DefaultAPICreateFpsTokenRequest

	// CreateFpsTokenExecute executes the request
	//  @return CreateFpsTokenResponse
	CreateFpsTokenExecute(r DefaultAPICreateFpsTokenRequest) (*CreateFpsTokenResponse, *http.Response, error)

	/*
		CreateMandateForExistingSender Method for CreateMandateForExistingSender

		Create mandate for an existing sender account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICreateMandateForExistingSenderRequest
	*/
	CreateMandateForExistingSender(ctx context.Context) DefaultAPICreateMandateForExistingSenderRequest

	// CreateMandateForExistingSenderExecute executes the request
	//  @return CreateMandateResponse
	CreateMandateForExistingSenderExecute(r DefaultAPICreateMandateForExistingSenderRequest) (*CreateMandateResponse, *http.Response, error)

	/*
		CreatePaymentLink Method for CreatePaymentLink

		Create payment link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICreatePaymentLinkRequest
	*/
	CreatePaymentLink(ctx context.Context) DefaultAPICreatePaymentLinkRequest

	// CreatePaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	CreatePaymentLinkExecute(r DefaultAPICreatePaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		CreatePaymentLinkCardPayment Method for CreatePaymentLinkCardPayment

		Initiate Card Payment for a Payment Link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICreatePaymentLinkCardPaymentRequest
	*/
	CreatePaymentLinkCardPayment(ctx context.Context) DefaultAPICreatePaymentLinkCardPaymentRequest

	// CreatePaymentLinkCardPaymentExecute executes the request
	//  @return CreatePaymentLinkCardPaymentResponse
	CreatePaymentLinkCardPaymentExecute(r DefaultAPICreatePaymentLinkCardPaymentRequest) (*CreatePaymentLinkCardPaymentResponse, *http.Response, error)

	/*
		CreatePaymentLinkMandate Method for CreatePaymentLinkMandate

		CREATE Mandate for payment link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICreatePaymentLinkMandateRequest
	*/
	CreatePaymentLinkMandate(ctx context.Context) DefaultAPICreatePaymentLinkMandateRequest

	// CreatePaymentLinkMandateExecute executes the request
	//  @return CreatePaymentLinkMandateResponse
	CreatePaymentLinkMandateExecute(r DefaultAPICreatePaymentLinkMandateRequest) (*CreatePaymentLinkMandateResponse, *http.Response, error)

	/*
		CreatePaymentMethod Method for CreatePaymentMethod

		Create a Payment Method for a user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param paymentUserId Payment User ID
		@return DefaultAPICreatePaymentMethodRequest
	*/
	CreatePaymentMethod(ctx context.Context, paymentUserId string) DefaultAPICreatePaymentMethodRequest

	// CreatePaymentMethodExecute executes the request
	//  @return PaymentMethodResponse
	CreatePaymentMethodExecute(r DefaultAPICreatePaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error)

	/*
		CreateScheduledPayout Method for CreateScheduledPayout

		Create a scheduled payout

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPICreateScheduledPayoutRequest
	*/
	CreateScheduledPayout(ctx context.Context) DefaultAPICreateScheduledPayoutRequest

	// CreateScheduledPayoutExecute executes the request
	//  @return PayoutSnapshotResponse
	CreateScheduledPayoutExecute(r DefaultAPICreateScheduledPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		DemotePaymentAttempt Method for DemotePaymentAttempt

		Demote payment attempt

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIDemotePaymentAttemptRequest
	*/
	DemotePaymentAttempt(ctx context.Context) DefaultAPIDemotePaymentAttemptRequest

	// DemotePaymentAttemptExecute executes the request
	DemotePaymentAttemptExecute(r DefaultAPIDemotePaymentAttemptRequest) (*http.Response, error)

	/*
		DownloadBalanceStatement Method for DownloadBalanceStatement

		Download the balance statement for the ledger (CSV)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIDownloadBalanceStatementRequest
	*/
	DownloadBalanceStatement(ctx context.Context) DefaultAPIDownloadBalanceStatementRequest

	// DownloadBalanceStatementExecute executes the request
	//  @return DownloadBalanceStatementResponse
	DownloadBalanceStatementExecute(r DefaultAPIDownloadBalanceStatementRequest) (*DownloadBalanceStatementResponse, *http.Response, error)

	/*
		GetFpsQrCode Method for GetFpsQrCode

		Get the FPS QR code

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIGetFpsQrCodeRequest
	*/
	GetFpsQrCode(ctx context.Context) DefaultAPIGetFpsQrCodeRequest

	// GetFpsQrCodeExecute executes the request
	//  @return FpsQrCodeResponse
	GetFpsQrCodeExecute(r DefaultAPIGetFpsQrCodeRequest) (*FpsQrCodeResponse, *http.Response, error)

	/*
		GetInstitutionsForCustomer Method for GetInstitutionsForCustomer

		Get a customer-specific list of institutions for Finverse Link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIGetInstitutionsForCustomerRequest
	*/
	GetInstitutionsForCustomer(ctx context.Context) DefaultAPIGetInstitutionsForCustomerRequest

	// GetInstitutionsForCustomerExecute executes the request
	//  @return []Institution
	GetInstitutionsForCustomerExecute(r DefaultAPIGetInstitutionsForCustomerRequest) ([]Institution, *http.Response, error)

	/*
		GetPaymentLink Method for GetPaymentLink

		Get payment link

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param paymentLinkId The payment link id
		@return DefaultAPIGetPaymentLinkRequest
	*/
	GetPaymentLink(ctx context.Context, paymentLinkId string) DefaultAPIGetPaymentLinkRequest

	// GetPaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	GetPaymentLinkExecute(r DefaultAPIGetPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		GetPaymentMethod Method for GetPaymentMethod

		Get a payment method

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param paymentMethodId
		@return DefaultAPIGetPaymentMethodRequest
	*/
	GetPaymentMethod(ctx context.Context, paymentMethodId string) DefaultAPIGetPaymentMethodRequest

	// GetPaymentMethodExecute executes the request
	//  @return PaymentMethodResponse
	GetPaymentMethodExecute(r DefaultAPIGetPaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error)

	/*
		GetPaymentMethodPaymentLink Method for GetPaymentMethodPaymentLink

		Get payment method in payment link flow

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIGetPaymentMethodPaymentLinkRequest
	*/
	GetPaymentMethodPaymentLink(ctx context.Context) DefaultAPIGetPaymentMethodPaymentLinkRequest

	// GetPaymentMethodPaymentLinkExecute executes the request
	//  @return PaymentMethodFvLinkResponse
	GetPaymentMethodPaymentLinkExecute(r DefaultAPIGetPaymentMethodPaymentLinkRequest) (*PaymentMethodFvLinkResponse, *http.Response, error)

	/*
		GetPaymentPaymentLink Method for GetPaymentPaymentLink

		Get payment (if exists) on the payment link for front-end

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIGetPaymentPaymentLinkRequest
	*/
	GetPaymentPaymentLink(ctx context.Context) DefaultAPIGetPaymentPaymentLinkRequest

	// GetPaymentPaymentLinkExecute executes the request
	//  @return PaymentFvLinkResponse
	GetPaymentPaymentLinkExecute(r DefaultAPIGetPaymentPaymentLinkRequest) (*PaymentFvLinkResponse, *http.Response, error)

	/*
		GetPayoutById Method for GetPayoutById

		Get payout by payout_id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param payoutId payout id
		@return DefaultAPIGetPayoutByIdRequest
	*/
	GetPayoutById(ctx context.Context, payoutId string) DefaultAPIGetPayoutByIdRequest

	// GetPayoutByIdExecute executes the request
	//  @return PayoutSnapshotResponse
	GetPayoutByIdExecute(r DefaultAPIGetPayoutByIdRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		GetSenderPaymentUser Method for GetSenderPaymentUser

		Get sender payment user in payment link flow

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIGetSenderPaymentUserRequest
	*/
	GetSenderPaymentUser(ctx context.Context) DefaultAPIGetSenderPaymentUserRequest

	// GetSenderPaymentUserExecute executes the request
	//  @return GetPaymentUserResponse
	GetSenderPaymentUserExecute(r DefaultAPIGetSenderPaymentUserRequest) (*GetPaymentUserResponse, *http.Response, error)

	/*
		ListAvailablePaymentMethodsPaymentLink Method for ListAvailablePaymentMethodsPaymentLink

		List available payment methods

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest
	*/
	ListAvailablePaymentMethodsPaymentLink(ctx context.Context) DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest

	// ListAvailablePaymentMethodsPaymentLinkExecute executes the request
	//  @return AvailablePaymentMethodsFvLinkResponse
	ListAvailablePaymentMethodsPaymentLinkExecute(r DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest) (*AvailablePaymentMethodsFvLinkResponse, *http.Response, error)

	/*
		ListDetokenizedMandates Method for ListDetokenizedMandates

		List mandates details

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIListDetokenizedMandatesRequest
	*/
	ListDetokenizedMandates(ctx context.Context) DefaultAPIListDetokenizedMandatesRequest

	// ListDetokenizedMandatesExecute executes the request
	//  @return ListMandatesResponse
	ListDetokenizedMandatesExecute(r DefaultAPIListDetokenizedMandatesRequest) (*ListMandatesResponse, *http.Response, error)

	/*
		ListDisputes Method for ListDisputes

		List Disputes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIListDisputesRequest
	*/
	ListDisputes(ctx context.Context) DefaultAPIListDisputesRequest

	// ListDisputesExecute executes the request
	//  @return ListDisputesResponse
	ListDisputesExecute(r DefaultAPIListDisputesRequest) (*ListDisputesResponse, *http.Response, error)

	/*
		ListMandates Method for ListMandates

		List mandates

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIListMandatesRequest
	*/
	ListMandates(ctx context.Context) DefaultAPIListMandatesRequest

	// ListMandatesExecute executes the request
	//  @return ListMandatesResponse
	ListMandatesExecute(r DefaultAPIListMandatesRequest) (*ListMandatesResponse, *http.Response, error)

	/*
		ListPaymentMethods Method for ListPaymentMethods

		List Payment Methods for a User

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param paymentUserId Payment User Id
		@return DefaultAPIListPaymentMethodsRequest
	*/
	ListPaymentMethods(ctx context.Context, paymentUserId string) DefaultAPIListPaymentMethodsRequest

	// ListPaymentMethodsExecute executes the request
	//  @return ListPaymentMethodsResponse
	ListPaymentMethodsExecute(r DefaultAPIListPaymentMethodsRequest) (*ListPaymentMethodsResponse, *http.Response, error)

	/*
		ListPayments Method for ListPayments

		List Payments

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIListPaymentsRequest
	*/
	ListPayments(ctx context.Context) DefaultAPIListPaymentsRequest

	// ListPaymentsExecute executes the request
	//  @return ListPaymentsResponse
	ListPaymentsExecute(r DefaultAPIListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error)

	/*
		ListPayouts Method for ListPayouts

		List payouts

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIListPayoutsRequest
	*/
	ListPayouts(ctx context.Context) DefaultAPIListPayoutsRequest

	// ListPayoutsExecute executes the request
	//  @return ListPayoutsResponse
	ListPayoutsExecute(r DefaultAPIListPayoutsRequest) (*ListPayoutsResponse, *http.Response, error)

	/*
		RefreshPaymentAttempt Method for RefreshPaymentAttempt

		Refresh payment attempt from payment link front-end

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPIRefreshPaymentAttemptRequest
	*/
	RefreshPaymentAttempt(ctx context.Context) DefaultAPIRefreshPaymentAttemptRequest

	// RefreshPaymentAttemptExecute executes the request
	//  @return RefreshPaymentAttemptResponse
	RefreshPaymentAttemptExecute(r DefaultAPIRefreshPaymentAttemptRequest) (*RefreshPaymentAttemptResponse, *http.Response, error)

	/*
		SetAutopayConsent Method for SetAutopayConsent

		Set autopay consent for payment user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultAPISetAutopayConsentRequest
	*/
	SetAutopayConsent(ctx context.Context) DefaultAPISetAutopayConsentRequest

	// SetAutopayConsentExecute executes the request
	SetAutopayConsentExecute(r DefaultAPISetAutopayConsentRequest) (*http.Response, error)

	/*
		UpdatePaymentUser Method for UpdatePaymentUser

		Update a payment user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param paymentUserId
		@return DefaultAPIUpdatePaymentUserRequest
	*/
	UpdatePaymentUser(ctx context.Context, paymentUserId string) DefaultAPIUpdatePaymentUserRequest

	// UpdatePaymentUserExecute executes the request
	//  @return PaymentUser
	UpdatePaymentUserExecute(r DefaultAPIUpdatePaymentUserRequest) (*PaymentUser, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type DefaultAPICancelPaymentLinkRequest struct {
	ctx           context.Context
	ApiService    DefaultAPI
	paymentLinkId string
}

func (r DefaultAPICancelPaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.CancelPaymentLinkExecute(r)
}

/*
CancelPaymentLink Method for CancelPaymentLink

Cancel a payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentLinkId The payment link id
 @return DefaultAPICancelPaymentLinkRequest
*/
func (a *DefaultAPIService) CancelPaymentLink(ctx context.Context, paymentLinkId string) DefaultAPICancelPaymentLinkRequest {
	return DefaultAPICancelPaymentLinkRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentLinkId: paymentLinkId,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultAPIService) CancelPaymentLinkExecute(r DefaultAPICancelPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CancelPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/{paymentLinkId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentLinkId"+"}", url.PathEscape(parameterValueToString(r.paymentLinkId, "paymentLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.paymentLinkId) < 1 {
		return localVarReturnValue, nil, reportError("paymentLinkId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICancelPayoutRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	payoutId   string
}

func (r DefaultAPICancelPayoutRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.CancelPayoutExecute(r)
}

/*
CancelPayout Method for CancelPayout

Cancel Payout by payout_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId payout id
 @return DefaultAPICancelPayoutRequest
*/
func (a *DefaultAPIService) CancelPayout(ctx context.Context, payoutId string) DefaultAPICancelPayoutRequest {
	return DefaultAPICancelPayoutRequest{
		ApiService: a,
		ctx:        ctx,
		payoutId:   payoutId,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultAPIService) CancelPayoutExecute(r DefaultAPICancelPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CancelPayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterValueToString(r.payoutId, "payoutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIChangePaymentMethodPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIChangePaymentMethodPaymentLinkRequest) Execute() (*ChangePaymentMethodFvLinkResponse, *http.Response, error) {
	return r.ApiService.ChangePaymentMethodPaymentLinkExecute(r)
}

/*
ChangePaymentMethodPaymentLink Method for ChangePaymentMethodPaymentLink

Initiate change payment method from payment link front-end

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIChangePaymentMethodPaymentLinkRequest
*/
func (a *DefaultAPIService) ChangePaymentMethodPaymentLink(ctx context.Context) DefaultAPIChangePaymentMethodPaymentLinkRequest {
	return DefaultAPIChangePaymentMethodPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ChangePaymentMethodFvLinkResponse
func (a *DefaultAPIService) ChangePaymentMethodPaymentLinkExecute(r DefaultAPIChangePaymentMethodPaymentLinkRequest) (*ChangePaymentMethodFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChangePaymentMethodFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ChangePaymentMethodPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_method/change"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICompleteKcpPaymentRequest struct {
	ctx                       context.Context
	ApiService                DefaultAPI
	completeKcpPaymentRequest *CompleteKcpPaymentRequest
}

// Parameters from the KCP SDK callback to complete the payment
func (r DefaultAPICompleteKcpPaymentRequest) CompleteKcpPaymentRequest(completeKcpPaymentRequest CompleteKcpPaymentRequest) DefaultAPICompleteKcpPaymentRequest {
	r.completeKcpPaymentRequest = &completeKcpPaymentRequest
	return r
}

func (r DefaultAPICompleteKcpPaymentRequest) Execute() (*CompleteKcpPaymentResponse, *http.Response, error) {
	return r.ApiService.CompleteKcpPaymentExecute(r)
}

/*
CompleteKcpPayment Method for CompleteKcpPayment

Complete a KCP payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICompleteKcpPaymentRequest
*/
func (a *DefaultAPIService) CompleteKcpPayment(ctx context.Context) DefaultAPICompleteKcpPaymentRequest {
	return DefaultAPICompleteKcpPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CompleteKcpPaymentResponse
func (a *DefaultAPIService) CompleteKcpPaymentExecute(r DefaultAPICompleteKcpPaymentRequest) (*CompleteKcpPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompleteKcpPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CompleteKcpPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/kcp/payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.completeKcpPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("completeKcpPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeKcpPaymentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIConfirmManualPaymentRequest struct {
	ctx                      context.Context
	ApiService               DefaultAPI
	manualPaymentIdentifiers *ManualPaymentConfirmationRequest
}

// Request body containing information to identify manual payment
func (r DefaultAPIConfirmManualPaymentRequest) ManualPaymentIdentifiers(manualPaymentIdentifiers ManualPaymentConfirmationRequest) DefaultAPIConfirmManualPaymentRequest {
	r.manualPaymentIdentifiers = &manualPaymentIdentifiers
	return r
}

func (r DefaultAPIConfirmManualPaymentRequest) Execute() (*ManualPaymentConfirmationResponse, *http.Response, error) {
	return r.ApiService.ConfirmManualPaymentExecute(r)
}

/*
ConfirmManualPayment Method for ConfirmManualPayment

Submit manual payment confirmation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIConfirmManualPaymentRequest
*/
func (a *DefaultAPIService) ConfirmManualPayment(ctx context.Context) DefaultAPIConfirmManualPaymentRequest {
	return DefaultAPIConfirmManualPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ManualPaymentConfirmationResponse
func (a *DefaultAPIService) ConfirmManualPaymentExecute(r DefaultAPIConfirmManualPaymentRequest) (*ManualPaymentConfirmationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManualPaymentConfirmationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfirmManualPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/manual_payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.manualPaymentIdentifiers == nil {
		return localVarReturnValue, nil, reportError("manualPaymentIdentifiers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manualPaymentIdentifiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIConfirmPaymentRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIConfirmPaymentRequest) Execute() (*ConfirmPaymentResponse, *http.Response, error) {
	return r.ApiService.ConfirmPaymentExecute(r)
}

/*
ConfirmPayment Method for ConfirmPayment

Confirm a payment against a payment Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIConfirmPaymentRequest
*/
func (a *DefaultAPIService) ConfirmPayment(ctx context.Context) DefaultAPIConfirmPaymentRequest {
	return DefaultAPIConfirmPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ConfirmPaymentResponse
func (a *DefaultAPIService) ConfirmPaymentExecute(r DefaultAPIConfirmPaymentRequest) (*ConfirmPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfirmPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfirmPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreateFpsTokenRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPICreateFpsTokenRequest) Execute() (*CreateFpsTokenResponse, *http.Response, error) {
	return r.ApiService.CreateFpsTokenExecute(r)
}

/*
CreateFpsToken Method for CreateFpsToken

Create token for fps flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreateFpsTokenRequest
*/
func (a *DefaultAPIService) CreateFpsToken(ctx context.Context) DefaultAPICreateFpsTokenRequest {
	return DefaultAPICreateFpsTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreateFpsTokenResponse
func (a *DefaultAPIService) CreateFpsTokenExecute(r DefaultAPICreateFpsTokenRequest) (*CreateFpsTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateFpsTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateFpsToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/fps/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreateMandateForExistingSenderRequest struct {
	ctx                  context.Context
	ApiService           DefaultAPI
	idempotencyKey       *string
	createMandateRequest *CreateMandateWithSenderAccountRequest
}

// A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
func (r DefaultAPICreateMandateForExistingSenderRequest) IdempotencyKey(idempotencyKey string) DefaultAPICreateMandateForExistingSenderRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// request body for creating mandate
func (r DefaultAPICreateMandateForExistingSenderRequest) CreateMandateRequest(createMandateRequest CreateMandateWithSenderAccountRequest) DefaultAPICreateMandateForExistingSenderRequest {
	r.createMandateRequest = &createMandateRequest
	return r
}

func (r DefaultAPICreateMandateForExistingSenderRequest) Execute() (*CreateMandateResponse, *http.Response, error) {
	return r.ApiService.CreateMandateForExistingSenderExecute(r)
}

/*
CreateMandateForExistingSender Method for CreateMandateForExistingSender

Create mandate for an existing sender account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreateMandateForExistingSenderRequest
*/
func (a *DefaultAPIService) CreateMandateForExistingSender(ctx context.Context) DefaultAPICreateMandateForExistingSenderRequest {
	return DefaultAPICreateMandateForExistingSenderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreateMandateResponse
func (a *DefaultAPIService) CreateMandateForExistingSenderExecute(r DefaultAPICreateMandateForExistingSenderRequest) (*CreateMandateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateMandateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateMandateForExistingSender")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates/sender_account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createMandateRequest == nil {
		return localVarReturnValue, nil, reportError("createMandateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "", "")
	// body params
	localVarPostBody = r.createMandateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatePaymentLinkRequest struct {
	ctx                      context.Context
	ApiService               DefaultAPI
	createPaymentLinkRequest *CreatePaymentLinkRequest
}

// Parameters required to create a payment link
func (r DefaultAPICreatePaymentLinkRequest) CreatePaymentLinkRequest(createPaymentLinkRequest CreatePaymentLinkRequest) DefaultAPICreatePaymentLinkRequest {
	r.createPaymentLinkRequest = &createPaymentLinkRequest
	return r
}

func (r DefaultAPICreatePaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkExecute(r)
}

/*
CreatePaymentLink Method for CreatePaymentLink

Create payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreatePaymentLinkRequest
*/
func (a *DefaultAPIService) CreatePaymentLink(ctx context.Context) DefaultAPICreatePaymentLinkRequest {
	return DefaultAPICreatePaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultAPIService) CreatePaymentLinkExecute(r DefaultAPICreatePaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatePaymentLinkCardPaymentRequest struct {
	ctx                                 context.Context
	ApiService                          DefaultAPI
	createPaymentLinkCardPaymentRequest *CreatePaymentLinkCardPaymentRequest
}

// request body for initiating card payment for a payment link
func (r DefaultAPICreatePaymentLinkCardPaymentRequest) CreatePaymentLinkCardPaymentRequest(createPaymentLinkCardPaymentRequest CreatePaymentLinkCardPaymentRequest) DefaultAPICreatePaymentLinkCardPaymentRequest {
	r.createPaymentLinkCardPaymentRequest = &createPaymentLinkCardPaymentRequest
	return r
}

func (r DefaultAPICreatePaymentLinkCardPaymentRequest) Execute() (*CreatePaymentLinkCardPaymentResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkCardPaymentExecute(r)
}

/*
CreatePaymentLinkCardPayment Method for CreatePaymentLinkCardPayment

Initiate Card Payment for a Payment Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreatePaymentLinkCardPaymentRequest
*/
func (a *DefaultAPIService) CreatePaymentLinkCardPayment(ctx context.Context) DefaultAPICreatePaymentLinkCardPaymentRequest {
	return DefaultAPICreatePaymentLinkCardPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentLinkCardPaymentResponse
func (a *DefaultAPIService) CreatePaymentLinkCardPaymentExecute(r DefaultAPICreatePaymentLinkCardPaymentRequest) (*CreatePaymentLinkCardPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePaymentLinkCardPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePaymentLinkCardPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/card"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkCardPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkCardPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkCardPaymentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatePaymentLinkMandateRequest struct {
	ctx                             context.Context
	ApiService                      DefaultAPI
	createPaymentLinkMandateRequest *CreatePaymentLinkMandateRequest
}

// request body for creating mandate for payment-link
func (r DefaultAPICreatePaymentLinkMandateRequest) CreatePaymentLinkMandateRequest(createPaymentLinkMandateRequest CreatePaymentLinkMandateRequest) DefaultAPICreatePaymentLinkMandateRequest {
	r.createPaymentLinkMandateRequest = &createPaymentLinkMandateRequest
	return r
}

func (r DefaultAPICreatePaymentLinkMandateRequest) Execute() (*CreatePaymentLinkMandateResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkMandateExecute(r)
}

/*
CreatePaymentLinkMandate Method for CreatePaymentLinkMandate

CREATE Mandate for payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreatePaymentLinkMandateRequest
*/
func (a *DefaultAPIService) CreatePaymentLinkMandate(ctx context.Context) DefaultAPICreatePaymentLinkMandateRequest {
	return DefaultAPICreatePaymentLinkMandateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentLinkMandateResponse
func (a *DefaultAPIService) CreatePaymentLinkMandateExecute(r DefaultAPICreatePaymentLinkMandateRequest) (*CreatePaymentLinkMandateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePaymentLinkMandateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePaymentLinkMandate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/mandates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkMandateRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkMandateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkMandateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatePaymentMethodRequest struct {
	ctx                        context.Context
	ApiService                 DefaultAPI
	paymentUserId              string
	createPaymentMethodRequest *CreatePaymentMethodRequest
}

func (r DefaultAPICreatePaymentMethodRequest) CreatePaymentMethodRequest(createPaymentMethodRequest CreatePaymentMethodRequest) DefaultAPICreatePaymentMethodRequest {
	r.createPaymentMethodRequest = &createPaymentMethodRequest
	return r
}

func (r DefaultAPICreatePaymentMethodRequest) Execute() (*PaymentMethodResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentMethodExecute(r)
}

/*
CreatePaymentMethod Method for CreatePaymentMethod

Create a Payment Method for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentUserId Payment User ID
 @return DefaultAPICreatePaymentMethodRequest
*/
func (a *DefaultAPIService) CreatePaymentMethod(ctx context.Context, paymentUserId string) DefaultAPICreatePaymentMethodRequest {
	return DefaultAPICreatePaymentMethodRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentUserId: paymentUserId,
	}
}

// Execute executes the request
//  @return PaymentMethodResponse
func (a *DefaultAPIService) CreatePaymentMethodExecute(r DefaultAPICreatePaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentMethodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_users/{paymentUserId}/payment_methods"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentUserId"+"}", url.PathEscape(parameterValueToString(r.paymentUserId, "paymentUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentMethodRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentMethodRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentMethodRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreateScheduledPayoutRequest struct {
	ctx                          context.Context
	ApiService                   DefaultAPI
	idempotencyKey               *string
	createScheduledPayoutRequest *CreateScheduledPayoutRequest
}

// A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
func (r DefaultAPICreateScheduledPayoutRequest) IdempotencyKey(idempotencyKey string) DefaultAPICreateScheduledPayoutRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Request body containing information to create scheduled payout
func (r DefaultAPICreateScheduledPayoutRequest) CreateScheduledPayoutRequest(createScheduledPayoutRequest CreateScheduledPayoutRequest) DefaultAPICreateScheduledPayoutRequest {
	r.createScheduledPayoutRequest = &createScheduledPayoutRequest
	return r
}

func (r DefaultAPICreateScheduledPayoutRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.CreateScheduledPayoutExecute(r)
}

/*
CreateScheduledPayout Method for CreateScheduledPayout

Create a scheduled payout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreateScheduledPayoutRequest
*/
func (a *DefaultAPIService) CreateScheduledPayout(ctx context.Context) DefaultAPICreateScheduledPayoutRequest {
	return DefaultAPICreateScheduledPayoutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultAPIService) CreateScheduledPayoutExecute(r DefaultAPICreateScheduledPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateScheduledPayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/scheduled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createScheduledPayoutRequest == nil {
		return localVarReturnValue, nil, reportError("createScheduledPayoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "", "")
	// body params
	localVarPostBody = r.createScheduledPayoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIDemotePaymentAttemptRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIDemotePaymentAttemptRequest) Execute() (*http.Response, error) {
	return r.ApiService.DemotePaymentAttemptExecute(r)
}

/*
DemotePaymentAttempt Method for DemotePaymentAttempt

Demote payment attempt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIDemotePaymentAttemptRequest
*/
func (a *DefaultAPIService) DemotePaymentAttempt(ctx context.Context) DefaultAPIDemotePaymentAttemptRequest {
	return DefaultAPIDemotePaymentAttemptRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DemotePaymentAttemptExecute(r DefaultAPIDemotePaymentAttemptRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DemotePaymentAttempt")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_attempt/demote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIDownloadBalanceStatementRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	dateFrom   *string
	dateTo     *string
	currencies *[]string
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIDownloadBalanceStatementRequest) DateFrom(dateFrom string) DefaultAPIDownloadBalanceStatementRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIDownloadBalanceStatementRequest) DateTo(dateTo string) DefaultAPIDownloadBalanceStatementRequest {
	r.dateTo = &dateTo
	return r
}

// The currencies to filter for
func (r DefaultAPIDownloadBalanceStatementRequest) Currencies(currencies []string) DefaultAPIDownloadBalanceStatementRequest {
	r.currencies = &currencies
	return r
}

func (r DefaultAPIDownloadBalanceStatementRequest) Execute() (*DownloadBalanceStatementResponse, *http.Response, error) {
	return r.ApiService.DownloadBalanceStatementExecute(r)
}

/*
DownloadBalanceStatement Method for DownloadBalanceStatement

Download the balance statement for the ledger (CSV)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIDownloadBalanceStatementRequest
*/
func (a *DefaultAPIService) DownloadBalanceStatement(ctx context.Context) DefaultAPIDownloadBalanceStatementRequest {
	return DefaultAPIDownloadBalanceStatementRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DownloadBalanceStatementResponse
func (a *DefaultAPIService) DownloadBalanceStatementExecute(r DefaultAPIDownloadBalanceStatementRequest) (*DownloadBalanceStatementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DownloadBalanceStatementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DownloadBalanceStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ledger/statement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "", "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "", "")
	}
	if r.currencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", r.currencies, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetFpsQrCodeRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIGetFpsQrCodeRequest) Execute() (*FpsQrCodeResponse, *http.Response, error) {
	return r.ApiService.GetFpsQrCodeExecute(r)
}

/*
GetFpsQrCode Method for GetFpsQrCode

Get the FPS QR code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetFpsQrCodeRequest
*/
func (a *DefaultAPIService) GetFpsQrCode(ctx context.Context) DefaultAPIGetFpsQrCodeRequest {
	return DefaultAPIGetFpsQrCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return FpsQrCodeResponse
func (a *DefaultAPIService) GetFpsQrCodeExecute(r DefaultAPIGetFpsQrCodeRequest) (*FpsQrCodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FpsQrCodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetFpsQrCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/fps/qr_code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetInstitutionsForCustomerRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIGetInstitutionsForCustomerRequest) Execute() ([]Institution, *http.Response, error) {
	return r.ApiService.GetInstitutionsForCustomerExecute(r)
}

/*
GetInstitutionsForCustomer Method for GetInstitutionsForCustomer

Get a customer-specific list of institutions for Finverse Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetInstitutionsForCustomerRequest
*/
func (a *DefaultAPIService) GetInstitutionsForCustomer(ctx context.Context) DefaultAPIGetInstitutionsForCustomerRequest {
	return DefaultAPIGetInstitutionsForCustomerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []Institution
func (a *DefaultAPIService) GetInstitutionsForCustomerExecute(r DefaultAPIGetInstitutionsForCustomerRequest) ([]Institution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Institution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetInstitutionsForCustomer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/institutions/customer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetPaymentLinkRequest struct {
	ctx           context.Context
	ApiService    DefaultAPI
	paymentLinkId string
}

func (r DefaultAPIGetPaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentLinkExecute(r)
}

/*
GetPaymentLink Method for GetPaymentLink

Get payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentLinkId The payment link id
 @return DefaultAPIGetPaymentLinkRequest
*/
func (a *DefaultAPIService) GetPaymentLink(ctx context.Context, paymentLinkId string) DefaultAPIGetPaymentLinkRequest {
	return DefaultAPIGetPaymentLinkRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentLinkId: paymentLinkId,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultAPIService) GetPaymentLinkExecute(r DefaultAPIGetPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/{paymentLinkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentLinkId"+"}", url.PathEscape(parameterValueToString(r.paymentLinkId, "paymentLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.paymentLinkId) < 1 {
		return localVarReturnValue, nil, reportError("paymentLinkId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetPaymentMethodRequest struct {
	ctx             context.Context
	ApiService      DefaultAPI
	paymentMethodId string
}

func (r DefaultAPIGetPaymentMethodRequest) Execute() (*PaymentMethodResponse, *http.Response, error) {
	return r.ApiService.GetPaymentMethodExecute(r)
}

/*
GetPaymentMethod Method for GetPaymentMethod

Get a payment method

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentMethodId
 @return DefaultAPIGetPaymentMethodRequest
*/
func (a *DefaultAPIService) GetPaymentMethod(ctx context.Context, paymentMethodId string) DefaultAPIGetPaymentMethodRequest {
	return DefaultAPIGetPaymentMethodRequest{
		ApiService:      a,
		ctx:             ctx,
		paymentMethodId: paymentMethodId,
	}
}

// Execute executes the request
//  @return PaymentMethodResponse
func (a *DefaultAPIService) GetPaymentMethodExecute(r DefaultAPIGetPaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentMethodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_methods/{paymentMethodId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentMethodId"+"}", url.PathEscape(parameterValueToString(r.paymentMethodId, "paymentMethodId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetPaymentMethodPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIGetPaymentMethodPaymentLinkRequest) Execute() (*PaymentMethodFvLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentMethodPaymentLinkExecute(r)
}

/*
GetPaymentMethodPaymentLink Method for GetPaymentMethodPaymentLink

Get payment method in payment link flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetPaymentMethodPaymentLinkRequest
*/
func (a *DefaultAPIService) GetPaymentMethodPaymentLink(ctx context.Context) DefaultAPIGetPaymentMethodPaymentLinkRequest {
	return DefaultAPIGetPaymentMethodPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentMethodFvLinkResponse
func (a *DefaultAPIService) GetPaymentMethodPaymentLinkExecute(r DefaultAPIGetPaymentMethodPaymentLinkRequest) (*PaymentMethodFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentMethodFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPaymentMethodPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_method"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetPaymentPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIGetPaymentPaymentLinkRequest) Execute() (*PaymentFvLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentPaymentLinkExecute(r)
}

/*
GetPaymentPaymentLink Method for GetPaymentPaymentLink

Get payment (if exists) on the payment link for front-end

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetPaymentPaymentLinkRequest
*/
func (a *DefaultAPIService) GetPaymentPaymentLink(ctx context.Context) DefaultAPIGetPaymentPaymentLinkRequest {
	return DefaultAPIGetPaymentPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentFvLinkResponse
func (a *DefaultAPIService) GetPaymentPaymentLinkExecute(r DefaultAPIGetPaymentPaymentLinkRequest) (*PaymentFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPaymentPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetPayoutByIdRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	payoutId   string
}

func (r DefaultAPIGetPayoutByIdRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.GetPayoutByIdExecute(r)
}

/*
GetPayoutById Method for GetPayoutById

Get payout by payout_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId payout id
 @return DefaultAPIGetPayoutByIdRequest
*/
func (a *DefaultAPIService) GetPayoutById(ctx context.Context, payoutId string) DefaultAPIGetPayoutByIdRequest {
	return DefaultAPIGetPayoutByIdRequest{
		ApiService: a,
		ctx:        ctx,
		payoutId:   payoutId,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultAPIService) GetPayoutByIdExecute(r DefaultAPIGetPayoutByIdRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPayoutById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterValueToString(r.payoutId, "payoutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetSenderPaymentUserRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIGetSenderPaymentUserRequest) Execute() (*GetPaymentUserResponse, *http.Response, error) {
	return r.ApiService.GetSenderPaymentUserExecute(r)
}

/*
GetSenderPaymentUser Method for GetSenderPaymentUser

Get sender payment user in payment link flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetSenderPaymentUserRequest
*/
func (a *DefaultAPIService) GetSenderPaymentUser(ctx context.Context) DefaultAPIGetSenderPaymentUserRequest {
	return DefaultAPIGetSenderPaymentUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetPaymentUserResponse
func (a *DefaultAPIService) GetSenderPaymentUserExecute(r DefaultAPIGetSenderPaymentUserRequest) (*GetPaymentUserResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetPaymentUserResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetSenderPaymentUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_user/sender"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest) Execute() (*AvailablePaymentMethodsFvLinkResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePaymentMethodsPaymentLinkExecute(r)
}

/*
ListAvailablePaymentMethodsPaymentLink Method for ListAvailablePaymentMethodsPaymentLink

List available payment methods

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest
*/
func (a *DefaultAPIService) ListAvailablePaymentMethodsPaymentLink(ctx context.Context) DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest {
	return DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AvailablePaymentMethodsFvLinkResponse
func (a *DefaultAPIService) ListAvailablePaymentMethodsPaymentLinkExecute(r DefaultAPIListAvailablePaymentMethodsPaymentLinkRequest) (*AvailablePaymentMethodsFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AvailablePaymentMethodsFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListAvailablePaymentMethodsPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/available_payment_methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListDetokenizedMandatesRequest struct {
	ctx           context.Context
	ApiService    DefaultAPI
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListDetokenizedMandatesRequest) DateFrom(dateFrom string) DefaultAPIListDetokenizedMandatesRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListDetokenizedMandatesRequest) DateTo(dateTo string) DefaultAPIListDetokenizedMandatesRequest {
	r.dateTo = &dateTo
	return r
}

// The mandate statuses to filter for, comma separated
func (r DefaultAPIListDetokenizedMandatesRequest) Statuses(statuses []string) DefaultAPIListDetokenizedMandatesRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultAPIListDetokenizedMandatesRequest) SenderType(senderType string) DefaultAPIListDetokenizedMandatesRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultAPIListDetokenizedMandatesRequest) UserId(userId string) DefaultAPIListDetokenizedMandatesRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultAPIListDetokenizedMandatesRequest) InstitutionId(institutionId string) DefaultAPIListDetokenizedMandatesRequest {
	r.institutionId = &institutionId
	return r
}

// default is 0
func (r DefaultAPIListDetokenizedMandatesRequest) Offset(offset int32) DefaultAPIListDetokenizedMandatesRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultAPIListDetokenizedMandatesRequest) Limit(limit int32) DefaultAPIListDetokenizedMandatesRequest {
	r.limit = &limit
	return r
}

func (r DefaultAPIListDetokenizedMandatesRequest) Execute() (*ListMandatesResponse, *http.Response, error) {
	return r.ApiService.ListDetokenizedMandatesExecute(r)
}

/*
ListDetokenizedMandates Method for ListDetokenizedMandates

List mandates details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIListDetokenizedMandatesRequest
*/
func (a *DefaultAPIService) ListDetokenizedMandates(ctx context.Context) DefaultAPIListDetokenizedMandatesRequest {
	return DefaultAPIListDetokenizedMandatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListMandatesResponse
func (a *DefaultAPIService) ListDetokenizedMandatesExecute(r DefaultAPIListDetokenizedMandatesRequest) (*ListMandatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMandatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListDetokenizedMandates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "", "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "csv")
	}
	if r.senderType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender_type", r.senderType, "", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "", "")
	}
	if r.institutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "institution_id", r.institutionId, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListDisputesRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
	dateFrom   *string
	dateTo     *string
	statuses   *[]string
	offset     *int32
	limit      *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListDisputesRequest) DateFrom(dateFrom string) DefaultAPIListDisputesRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListDisputesRequest) DateTo(dateTo string) DefaultAPIListDisputesRequest {
	r.dateTo = &dateTo
	return r
}

// The dispute statuses to filter for, comma separated
func (r DefaultAPIListDisputesRequest) Statuses(statuses []string) DefaultAPIListDisputesRequest {
	r.statuses = &statuses
	return r
}

// default is 0
func (r DefaultAPIListDisputesRequest) Offset(offset int32) DefaultAPIListDisputesRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultAPIListDisputesRequest) Limit(limit int32) DefaultAPIListDisputesRequest {
	r.limit = &limit
	return r
}

func (r DefaultAPIListDisputesRequest) Execute() (*ListDisputesResponse, *http.Response, error) {
	return r.ApiService.ListDisputesExecute(r)
}

/*
ListDisputes Method for ListDisputes

List Disputes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIListDisputesRequest
*/
func (a *DefaultAPIService) ListDisputes(ctx context.Context) DefaultAPIListDisputesRequest {
	return DefaultAPIListDisputesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListDisputesResponse
func (a *DefaultAPIService) ListDisputesExecute(r DefaultAPIListDisputesRequest) (*ListDisputesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListDisputesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListDisputes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disputes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "", "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListMandatesRequest struct {
	ctx           context.Context
	ApiService    DefaultAPI
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListMandatesRequest) DateFrom(dateFrom string) DefaultAPIListMandatesRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListMandatesRequest) DateTo(dateTo string) DefaultAPIListMandatesRequest {
	r.dateTo = &dateTo
	return r
}

// The mandate statuses to filter for, comma separated
func (r DefaultAPIListMandatesRequest) Statuses(statuses []string) DefaultAPIListMandatesRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultAPIListMandatesRequest) SenderType(senderType string) DefaultAPIListMandatesRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultAPIListMandatesRequest) UserId(userId string) DefaultAPIListMandatesRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultAPIListMandatesRequest) InstitutionId(institutionId string) DefaultAPIListMandatesRequest {
	r.institutionId = &institutionId
	return r
}

// default is 0
func (r DefaultAPIListMandatesRequest) Offset(offset int32) DefaultAPIListMandatesRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultAPIListMandatesRequest) Limit(limit int32) DefaultAPIListMandatesRequest {
	r.limit = &limit
	return r
}

func (r DefaultAPIListMandatesRequest) Execute() (*ListMandatesResponse, *http.Response, error) {
	return r.ApiService.ListMandatesExecute(r)
}

/*
ListMandates Method for ListMandates

List mandates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIListMandatesRequest
*/
func (a *DefaultAPIService) ListMandates(ctx context.Context) DefaultAPIListMandatesRequest {
	return DefaultAPIListMandatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListMandatesResponse
func (a *DefaultAPIService) ListMandatesExecute(r DefaultAPIListMandatesRequest) (*ListMandatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMandatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListMandates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "", "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "csv")
	}
	if r.senderType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender_type", r.senderType, "", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "", "")
	}
	if r.institutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "institution_id", r.institutionId, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListPaymentMethodsRequest struct {
	ctx           context.Context
	ApiService    DefaultAPI
	paymentUserId string
}

func (r DefaultAPIListPaymentMethodsRequest) Execute() (*ListPaymentMethodsResponse, *http.Response, error) {
	return r.ApiService.ListPaymentMethodsExecute(r)
}

/*
ListPaymentMethods Method for ListPaymentMethods

List Payment Methods for a User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentUserId Payment User Id
 @return DefaultAPIListPaymentMethodsRequest
*/
func (a *DefaultAPIService) ListPaymentMethods(ctx context.Context, paymentUserId string) DefaultAPIListPaymentMethodsRequest {
	return DefaultAPIListPaymentMethodsRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentUserId: paymentUserId,
	}
}

// Execute executes the request
//  @return ListPaymentMethodsResponse
func (a *DefaultAPIService) ListPaymentMethodsExecute(r DefaultAPIListPaymentMethodsRequest) (*ListPaymentMethodsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPaymentMethodsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_users/{paymentUserId}/payment_methods"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentUserId"+"}", url.PathEscape(parameterValueToString(r.paymentUserId, "paymentUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListPaymentsRequest struct {
	ctx           context.Context
	ApiService    DefaultAPI
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	paymentType   *string
	paymentTypes  *[]string
	mandateId     *string
	currency      *string
	currencies    *[]string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListPaymentsRequest) DateFrom(dateFrom string) DefaultAPIListPaymentsRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListPaymentsRequest) DateTo(dateTo string) DefaultAPIListPaymentsRequest {
	r.dateTo = &dateTo
	return r
}

// The payment statuses to filter for, comma separated
func (r DefaultAPIListPaymentsRequest) Statuses(statuses []string) DefaultAPIListPaymentsRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultAPIListPaymentsRequest) SenderType(senderType string) DefaultAPIListPaymentsRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultAPIListPaymentsRequest) UserId(userId string) DefaultAPIListPaymentsRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultAPIListPaymentsRequest) InstitutionId(institutionId string) DefaultAPIListPaymentsRequest {
	r.institutionId = &institutionId
	return r
}

// Deprecated - The type of payment
func (r DefaultAPIListPaymentsRequest) PaymentType(paymentType string) DefaultAPIListPaymentsRequest {
	r.paymentType = &paymentType
	return r
}

func (r DefaultAPIListPaymentsRequest) PaymentTypes(paymentTypes []string) DefaultAPIListPaymentsRequest {
	r.paymentTypes = &paymentTypes
	return r
}

// The mandate the payment belongs to
func (r DefaultAPIListPaymentsRequest) MandateId(mandateId string) DefaultAPIListPaymentsRequest {
	r.mandateId = &mandateId
	return r
}

// Deprecated - The currency the payment is made in
func (r DefaultAPIListPaymentsRequest) Currency(currency string) DefaultAPIListPaymentsRequest {
	r.currency = &currency
	return r
}

func (r DefaultAPIListPaymentsRequest) Currencies(currencies []string) DefaultAPIListPaymentsRequest {
	r.currencies = &currencies
	return r
}

// default is 0
func (r DefaultAPIListPaymentsRequest) Offset(offset int32) DefaultAPIListPaymentsRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultAPIListPaymentsRequest) Limit(limit int32) DefaultAPIListPaymentsRequest {
	r.limit = &limit
	return r
}

func (r DefaultAPIListPaymentsRequest) Execute() (*ListPaymentsResponse, *http.Response, error) {
	return r.ApiService.ListPaymentsExecute(r)
}

/*
ListPayments Method for ListPayments

List Payments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIListPaymentsRequest
*/
func (a *DefaultAPIService) ListPayments(ctx context.Context) DefaultAPIListPaymentsRequest {
	return DefaultAPIListPaymentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListPaymentsResponse
func (a *DefaultAPIService) ListPaymentsExecute(r DefaultAPIListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPaymentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "", "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "csv")
	}
	if r.senderType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender_type", r.senderType, "", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "", "")
	}
	if r.institutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "institution_id", r.institutionId, "", "")
	}
	if r.paymentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payment_type", r.paymentType, "", "")
	}
	if r.paymentTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payment_types", r.paymentTypes, "form", "csv")
	}
	if r.mandateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mandate_id", r.mandateId, "", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.currencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", r.currencies, "form", "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIListPayoutsRequest struct {
	ctx                     context.Context
	ApiService              DefaultAPI
	dateFrom                *string
	dateTo                  *string
	statuses                *[]string
	currencies              *[]string
	payoutTypes             *[]string
	mandateId               *string
	senderAccountId         *string
	recipientAccountId      *string
	recipientUserId         *string
	recipientExternalUserId *string
	offset                  *int32
	limit                   *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListPayoutsRequest) DateFrom(dateFrom string) DefaultAPIListPayoutsRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultAPIListPayoutsRequest) DateTo(dateTo string) DefaultAPIListPayoutsRequest {
	r.dateTo = &dateTo
	return r
}

// The payout statuses to filter for, comma separated
func (r DefaultAPIListPayoutsRequest) Statuses(statuses []string) DefaultAPIListPayoutsRequest {
	r.statuses = &statuses
	return r
}

func (r DefaultAPIListPayoutsRequest) Currencies(currencies []string) DefaultAPIListPayoutsRequest {
	r.currencies = &currencies
	return r
}

func (r DefaultAPIListPayoutsRequest) PayoutTypes(payoutTypes []string) DefaultAPIListPayoutsRequest {
	r.payoutTypes = &payoutTypes
	return r
}

func (r DefaultAPIListPayoutsRequest) MandateId(mandateId string) DefaultAPIListPayoutsRequest {
	r.mandateId = &mandateId
	return r
}

func (r DefaultAPIListPayoutsRequest) SenderAccountId(senderAccountId string) DefaultAPIListPayoutsRequest {
	r.senderAccountId = &senderAccountId
	return r
}

func (r DefaultAPIListPayoutsRequest) RecipientAccountId(recipientAccountId string) DefaultAPIListPayoutsRequest {
	r.recipientAccountId = &recipientAccountId
	return r
}

func (r DefaultAPIListPayoutsRequest) RecipientUserId(recipientUserId string) DefaultAPIListPayoutsRequest {
	r.recipientUserId = &recipientUserId
	return r
}

func (r DefaultAPIListPayoutsRequest) RecipientExternalUserId(recipientExternalUserId string) DefaultAPIListPayoutsRequest {
	r.recipientExternalUserId = &recipientExternalUserId
	return r
}

// Default is 0
func (r DefaultAPIListPayoutsRequest) Offset(offset int32) DefaultAPIListPayoutsRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultAPIListPayoutsRequest) Limit(limit int32) DefaultAPIListPayoutsRequest {
	r.limit = &limit
	return r
}

func (r DefaultAPIListPayoutsRequest) Execute() (*ListPayoutsResponse, *http.Response, error) {
	return r.ApiService.ListPayoutsExecute(r)
}

/*
ListPayouts Method for ListPayouts

List payouts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIListPayoutsRequest
*/
func (a *DefaultAPIService) ListPayouts(ctx context.Context) DefaultAPIListPayoutsRequest {
	return DefaultAPIListPayoutsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListPayoutsResponse
func (a *DefaultAPIService) ListPayoutsExecute(r DefaultAPIListPayoutsRequest) (*ListPayoutsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPayoutsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListPayouts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "", "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "csv")
	}
	if r.currencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", r.currencies, "form", "csv")
	}
	if r.payoutTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payout_types", r.payoutTypes, "form", "csv")
	}
	if r.mandateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mandate_id", r.mandateId, "", "")
	}
	if r.senderAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender_account_id", r.senderAccountId, "", "")
	}
	if r.recipientAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_account_id", r.recipientAccountId, "", "")
	}
	if r.recipientUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_user_id", r.recipientUserId, "", "")
	}
	if r.recipientExternalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_external_user_id", r.recipientExternalUserId, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIRefreshPaymentAttemptRequest struct {
	ctx        context.Context
	ApiService DefaultAPI
}

func (r DefaultAPIRefreshPaymentAttemptRequest) Execute() (*RefreshPaymentAttemptResponse, *http.Response, error) {
	return r.ApiService.RefreshPaymentAttemptExecute(r)
}

/*
RefreshPaymentAttempt Method for RefreshPaymentAttempt

Refresh payment attempt from payment link front-end

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIRefreshPaymentAttemptRequest
*/
func (a *DefaultAPIService) RefreshPaymentAttempt(ctx context.Context) DefaultAPIRefreshPaymentAttemptRequest {
	return DefaultAPIRefreshPaymentAttemptRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return RefreshPaymentAttemptResponse
func (a *DefaultAPIService) RefreshPaymentAttemptExecute(r DefaultAPIRefreshPaymentAttemptRequest) (*RefreshPaymentAttemptResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RefreshPaymentAttemptResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RefreshPaymentAttempt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_attempt/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISetAutopayConsentRequest struct {
	ctx                      context.Context
	ApiService               DefaultAPI
	setAutopayConsentRequest *SetAutopayConsentRequest
}

func (r DefaultAPISetAutopayConsentRequest) SetAutopayConsentRequest(setAutopayConsentRequest SetAutopayConsentRequest) DefaultAPISetAutopayConsentRequest {
	r.setAutopayConsentRequest = &setAutopayConsentRequest
	return r
}

func (r DefaultAPISetAutopayConsentRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutopayConsentExecute(r)
}

/*
SetAutopayConsent Method for SetAutopayConsent

Set autopay consent for payment user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISetAutopayConsentRequest
*/
func (a *DefaultAPIService) SetAutopayConsent(ctx context.Context) DefaultAPISetAutopayConsentRequest {
	return DefaultAPISetAutopayConsentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SetAutopayConsentExecute(r DefaultAPISetAutopayConsentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetAutopayConsent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_user/autopay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setAutopayConsentRequest == nil {
		return nil, reportError("setAutopayConsentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setAutopayConsentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultAPIUpdatePaymentUserRequest struct {
	ctx                      context.Context
	ApiService               DefaultAPI
	paymentUserId            string
	updatePaymentUserRequest *UpdatePaymentUserRequest
}

// request body for updating payment user
func (r DefaultAPIUpdatePaymentUserRequest) UpdatePaymentUserRequest(updatePaymentUserRequest UpdatePaymentUserRequest) DefaultAPIUpdatePaymentUserRequest {
	r.updatePaymentUserRequest = &updatePaymentUserRequest
	return r
}

func (r DefaultAPIUpdatePaymentUserRequest) Execute() (*PaymentUser, *http.Response, error) {
	return r.ApiService.UpdatePaymentUserExecute(r)
}

/*
UpdatePaymentUser Method for UpdatePaymentUser

Update a payment user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentUserId
 @return DefaultAPIUpdatePaymentUserRequest
*/
func (a *DefaultAPIService) UpdatePaymentUser(ctx context.Context, paymentUserId string) DefaultAPIUpdatePaymentUserRequest {
	return DefaultAPIUpdatePaymentUserRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentUserId: paymentUserId,
	}
}

// Execute executes the request
//  @return PaymentUser
func (a *DefaultAPIService) UpdatePaymentUserExecute(r DefaultAPIUpdatePaymentUserRequest) (*PaymentUser, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdatePaymentUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_users/{paymentUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentUserId"+"}", url.PathEscape(parameterValueToString(r.paymentUserId, "paymentUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePaymentUserRequest == nil {
		return localVarReturnValue, nil, reportError("updatePaymentUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePaymentUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
