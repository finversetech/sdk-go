/*
Finverse Public

Documentation of the early finverse services

API version: 0.0.1
Contact: info@finverse.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package finverse

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type DefaultApi interface {

	/*
		CancelPaymentLink Method for CancelPaymentLink

		Cancel a payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentLinkId The payment link id
		 @return DefaultApiApiCancelPaymentLinkRequest
	*/
	CancelPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiCancelPaymentLinkRequest

	// CancelPaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	CancelPaymentLinkExecute(r DefaultApiApiCancelPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		CancelPayout Method for CancelPayout

		Cancel Payout by payout_id

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param payoutId payout id
		 @return DefaultApiApiCancelPayoutRequest
	*/
	CancelPayout(ctx context.Context, payoutId string) DefaultApiApiCancelPayoutRequest

	// CancelPayoutExecute executes the request
	//  @return PayoutSnapshotResponse
	CancelPayoutExecute(r DefaultApiApiCancelPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		ConfirmManualPayment Method for ConfirmManualPayment

		Submit manual payment confirmation

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiConfirmManualPaymentRequest
	*/
	ConfirmManualPayment(ctx context.Context) DefaultApiApiConfirmManualPaymentRequest

	// ConfirmManualPaymentExecute executes the request
	//  @return ManualPaymentConfirmationResponse
	ConfirmManualPaymentExecute(r DefaultApiApiConfirmManualPaymentRequest) (*ManualPaymentConfirmationResponse, *http.Response, error)

	/*
		ConfirmPayment Method for ConfirmPayment

		Confirm a payment against a payment Link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiConfirmPaymentRequest
	*/
	ConfirmPayment(ctx context.Context) DefaultApiApiConfirmPaymentRequest

	// ConfirmPaymentExecute executes the request
	//  @return ConfirmPaymentResponse
	ConfirmPaymentExecute(r DefaultApiApiConfirmPaymentRequest) (*ConfirmPaymentResponse, *http.Response, error)

	/*
		CreateFpsToken Method for CreateFpsToken

		Create token for fps flow

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreateFpsTokenRequest
	*/
	CreateFpsToken(ctx context.Context) DefaultApiApiCreateFpsTokenRequest

	// CreateFpsTokenExecute executes the request
	//  @return CreateFpsTokenResponse
	CreateFpsTokenExecute(r DefaultApiApiCreateFpsTokenRequest) (*CreateFpsTokenResponse, *http.Response, error)

	/*
		CreateMandateForExistingSender Method for CreateMandateForExistingSender

		Create mandate for an existing sender account

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreateMandateForExistingSenderRequest
	*/
	CreateMandateForExistingSender(ctx context.Context) DefaultApiApiCreateMandateForExistingSenderRequest

	// CreateMandateForExistingSenderExecute executes the request
	//  @return CreateMandateResponse
	CreateMandateForExistingSenderExecute(r DefaultApiApiCreateMandateForExistingSenderRequest) (*CreateMandateResponse, *http.Response, error)

	/*
		CreatePaymentLink Method for CreatePaymentLink

		Create payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreatePaymentLinkRequest
	*/
	CreatePaymentLink(ctx context.Context) DefaultApiApiCreatePaymentLinkRequest

	// CreatePaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	CreatePaymentLinkExecute(r DefaultApiApiCreatePaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		CreatePaymentLinkCardPayment Method for CreatePaymentLinkCardPayment

		Initiate Card Payment for a Payment Link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreatePaymentLinkCardPaymentRequest
	*/
	CreatePaymentLinkCardPayment(ctx context.Context) DefaultApiApiCreatePaymentLinkCardPaymentRequest

	// CreatePaymentLinkCardPaymentExecute executes the request
	//  @return CreatePaymentLinkCardPaymentResponse
	CreatePaymentLinkCardPaymentExecute(r DefaultApiApiCreatePaymentLinkCardPaymentRequest) (*CreatePaymentLinkCardPaymentResponse, *http.Response, error)

	/*
		CreatePaymentLinkMandate Method for CreatePaymentLinkMandate

		CREATE Mandate for payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreatePaymentLinkMandateRequest
	*/
	CreatePaymentLinkMandate(ctx context.Context) DefaultApiApiCreatePaymentLinkMandateRequest

	// CreatePaymentLinkMandateExecute executes the request
	//  @return CreatePaymentLinkMandateResponse
	CreatePaymentLinkMandateExecute(r DefaultApiApiCreatePaymentLinkMandateRequest) (*CreatePaymentLinkMandateResponse, *http.Response, error)

	/*
		CreateScheduledPayout Method for CreateScheduledPayout

		Create a scheduled payout

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreateScheduledPayoutRequest
	*/
	CreateScheduledPayout(ctx context.Context) DefaultApiApiCreateScheduledPayoutRequest

	// CreateScheduledPayoutExecute executes the request
	//  @return PayoutSnapshotResponse
	CreateScheduledPayoutExecute(r DefaultApiApiCreateScheduledPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		GetFpsQrCode Method for GetFpsQrCode

		Get the FPS QR code

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetFpsQrCodeRequest
	*/
	GetFpsQrCode(ctx context.Context) DefaultApiApiGetFpsQrCodeRequest

	// GetFpsQrCodeExecute executes the request
	//  @return FpsQrCodeResponse
	GetFpsQrCodeExecute(r DefaultApiApiGetFpsQrCodeRequest) (*FpsQrCodeResponse, *http.Response, error)

	/*
		GetInstitutionsForCustomer Method for GetInstitutionsForCustomer

		Get a customer-specific list of institutions for Finverse Link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetInstitutionsForCustomerRequest
	*/
	GetInstitutionsForCustomer(ctx context.Context) DefaultApiApiGetInstitutionsForCustomerRequest

	// GetInstitutionsForCustomerExecute executes the request
	//  @return []Institution
	GetInstitutionsForCustomerExecute(r DefaultApiApiGetInstitutionsForCustomerRequest) ([]Institution, *http.Response, error)

	/*
		GetPaymentLink Method for GetPaymentLink

		Get payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentLinkId The payment link id
		 @return DefaultApiApiGetPaymentLinkRequest
	*/
	GetPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiGetPaymentLinkRequest

	// GetPaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	GetPaymentLinkExecute(r DefaultApiApiGetPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		GetPayoutById Method for GetPayoutById

		Get payout by payout_id

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param payoutId payout id
		 @return DefaultApiApiGetPayoutByIdRequest
	*/
	GetPayoutById(ctx context.Context, payoutId string) DefaultApiApiGetPayoutByIdRequest

	// GetPayoutByIdExecute executes the request
	//  @return PayoutSnapshotResponse
	GetPayoutByIdExecute(r DefaultApiApiGetPayoutByIdRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		GetSenderPaymentUser Method for GetSenderPaymentUser

		Get sender payment user in payment link flow

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetSenderPaymentUserRequest
	*/
	GetSenderPaymentUser(ctx context.Context) DefaultApiApiGetSenderPaymentUserRequest

	// GetSenderPaymentUserExecute executes the request
	//  @return GetPaymentUserResponse
	GetSenderPaymentUserExecute(r DefaultApiApiGetSenderPaymentUserRequest) (*GetPaymentUserResponse, *http.Response, error)

	/*
		ListMandates Method for ListMandates

		List mandates

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiListMandatesRequest
	*/
	ListMandates(ctx context.Context) DefaultApiApiListMandatesRequest

	// ListMandatesExecute executes the request
	//  @return ListMandatesResponse
	ListMandatesExecute(r DefaultApiApiListMandatesRequest) (*ListMandatesResponse, *http.Response, error)

	/*
		ListPayments Method for ListPayments

		List Payments

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiListPaymentsRequest
	*/
	ListPayments(ctx context.Context) DefaultApiApiListPaymentsRequest

	// ListPaymentsExecute executes the request
	//  @return ListPaymentsResponse
	ListPaymentsExecute(r DefaultApiApiListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error)

	/*
		SetAutopayConsent Method for SetAutopayConsent

		Set autopay consent for payment user

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiSetAutopayConsentRequest
	*/
	SetAutopayConsent(ctx context.Context) DefaultApiApiSetAutopayConsentRequest

	// SetAutopayConsentExecute executes the request
	SetAutopayConsentExecute(r DefaultApiApiSetAutopayConsentRequest) (*http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiApiCancelPaymentLinkRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	paymentLinkId string
}

func (r DefaultApiApiCancelPaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.CancelPaymentLinkExecute(r)
}

/*
CancelPaymentLink Method for CancelPaymentLink

Cancel a payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentLinkId The payment link id
 @return DefaultApiApiCancelPaymentLinkRequest
*/
func (a *DefaultApiService) CancelPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiCancelPaymentLinkRequest {
	return DefaultApiApiCancelPaymentLinkRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentLinkId: paymentLinkId,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultApiService) CancelPaymentLinkExecute(r DefaultApiApiCancelPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CancelPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/{paymentLinkId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentLinkId"+"}", url.PathEscape(parameterToString(r.paymentLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.paymentLinkId) < 1 {
		return localVarReturnValue, nil, reportError("paymentLinkId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCancelPayoutRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	payoutId   string
}

func (r DefaultApiApiCancelPayoutRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.CancelPayoutExecute(r)
}

/*
CancelPayout Method for CancelPayout

Cancel Payout by payout_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId payout id
 @return DefaultApiApiCancelPayoutRequest
*/
func (a *DefaultApiService) CancelPayout(ctx context.Context, payoutId string) DefaultApiApiCancelPayoutRequest {
	return DefaultApiApiCancelPayoutRequest{
		ApiService: a,
		ctx:        ctx,
		payoutId:   payoutId,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultApiService) CancelPayoutExecute(r DefaultApiApiCancelPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CancelPayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterToString(r.payoutId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiConfirmManualPaymentRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	manualPaymentIdentifiers *ManualPaymentConfirmationRequest
}

// Request body containing information to identify manual payment
func (r DefaultApiApiConfirmManualPaymentRequest) ManualPaymentIdentifiers(manualPaymentIdentifiers ManualPaymentConfirmationRequest) DefaultApiApiConfirmManualPaymentRequest {
	r.manualPaymentIdentifiers = &manualPaymentIdentifiers
	return r
}

func (r DefaultApiApiConfirmManualPaymentRequest) Execute() (*ManualPaymentConfirmationResponse, *http.Response, error) {
	return r.ApiService.ConfirmManualPaymentExecute(r)
}

/*
ConfirmManualPayment Method for ConfirmManualPayment

Submit manual payment confirmation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiConfirmManualPaymentRequest
*/
func (a *DefaultApiService) ConfirmManualPayment(ctx context.Context) DefaultApiApiConfirmManualPaymentRequest {
	return DefaultApiApiConfirmManualPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ManualPaymentConfirmationResponse
func (a *DefaultApiService) ConfirmManualPaymentExecute(r DefaultApiApiConfirmManualPaymentRequest) (*ManualPaymentConfirmationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManualPaymentConfirmationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConfirmManualPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/manual_payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.manualPaymentIdentifiers == nil {
		return localVarReturnValue, nil, reportError("manualPaymentIdentifiers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manualPaymentIdentifiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiConfirmPaymentRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiConfirmPaymentRequest) Execute() (*ConfirmPaymentResponse, *http.Response, error) {
	return r.ApiService.ConfirmPaymentExecute(r)
}

/*
ConfirmPayment Method for ConfirmPayment

Confirm a payment against a payment Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiConfirmPaymentRequest
*/
func (a *DefaultApiService) ConfirmPayment(ctx context.Context) DefaultApiApiConfirmPaymentRequest {
	return DefaultApiApiConfirmPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ConfirmPaymentResponse
func (a *DefaultApiService) ConfirmPaymentExecute(r DefaultApiApiConfirmPaymentRequest) (*ConfirmPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfirmPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConfirmPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateFpsTokenRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiCreateFpsTokenRequest) Execute() (*CreateFpsTokenResponse, *http.Response, error) {
	return r.ApiService.CreateFpsTokenExecute(r)
}

/*
CreateFpsToken Method for CreateFpsToken

Create token for fps flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreateFpsTokenRequest
*/
func (a *DefaultApiService) CreateFpsToken(ctx context.Context) DefaultApiApiCreateFpsTokenRequest {
	return DefaultApiApiCreateFpsTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreateFpsTokenResponse
func (a *DefaultApiService) CreateFpsTokenExecute(r DefaultApiApiCreateFpsTokenRequest) (*CreateFpsTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateFpsTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateFpsToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/fps/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateMandateForExistingSenderRequest struct {
	ctx                  context.Context
	ApiService           DefaultApi
	idempotencyKey       *string
	createMandateRequest *CreateMandateWithSenderAccountRequest
}

// A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
func (r DefaultApiApiCreateMandateForExistingSenderRequest) IdempotencyKey(idempotencyKey string) DefaultApiApiCreateMandateForExistingSenderRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// request body for creating mandate
func (r DefaultApiApiCreateMandateForExistingSenderRequest) CreateMandateRequest(createMandateRequest CreateMandateWithSenderAccountRequest) DefaultApiApiCreateMandateForExistingSenderRequest {
	r.createMandateRequest = &createMandateRequest
	return r
}

func (r DefaultApiApiCreateMandateForExistingSenderRequest) Execute() (*CreateMandateResponse, *http.Response, error) {
	return r.ApiService.CreateMandateForExistingSenderExecute(r)
}

/*
CreateMandateForExistingSender Method for CreateMandateForExistingSender

Create mandate for an existing sender account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreateMandateForExistingSenderRequest
*/
func (a *DefaultApiService) CreateMandateForExistingSender(ctx context.Context) DefaultApiApiCreateMandateForExistingSenderRequest {
	return DefaultApiApiCreateMandateForExistingSenderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreateMandateResponse
func (a *DefaultApiService) CreateMandateForExistingSenderExecute(r DefaultApiApiCreateMandateForExistingSenderRequest) (*CreateMandateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateMandateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMandateForExistingSender")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates/sender_account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createMandateRequest == nil {
		return localVarReturnValue, nil, reportError("createMandateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Idempotency-Key"] = parameterToString(*r.idempotencyKey, "")
	// body params
	localVarPostBody = r.createMandateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentLinkRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	createPaymentLinkRequest *CreatePaymentLinkRequest
}

// Parameters required to create a payment link
func (r DefaultApiApiCreatePaymentLinkRequest) CreatePaymentLinkRequest(createPaymentLinkRequest CreatePaymentLinkRequest) DefaultApiApiCreatePaymentLinkRequest {
	r.createPaymentLinkRequest = &createPaymentLinkRequest
	return r
}

func (r DefaultApiApiCreatePaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkExecute(r)
}

/*
CreatePaymentLink Method for CreatePaymentLink

Create payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreatePaymentLinkRequest
*/
func (a *DefaultApiService) CreatePaymentLink(ctx context.Context) DefaultApiApiCreatePaymentLinkRequest {
	return DefaultApiApiCreatePaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultApiService) CreatePaymentLinkExecute(r DefaultApiApiCreatePaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentLinkCardPaymentRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiCreatePaymentLinkCardPaymentRequest) Execute() (*CreatePaymentLinkCardPaymentResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkCardPaymentExecute(r)
}

/*
CreatePaymentLinkCardPayment Method for CreatePaymentLinkCardPayment

Initiate Card Payment for a Payment Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreatePaymentLinkCardPaymentRequest
*/
func (a *DefaultApiService) CreatePaymentLinkCardPayment(ctx context.Context) DefaultApiApiCreatePaymentLinkCardPaymentRequest {
	return DefaultApiApiCreatePaymentLinkCardPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentLinkCardPaymentResponse
func (a *DefaultApiService) CreatePaymentLinkCardPaymentExecute(r DefaultApiApiCreatePaymentLinkCardPaymentRequest) (*CreatePaymentLinkCardPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePaymentLinkCardPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentLinkCardPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/card"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentLinkMandateRequest struct {
	ctx                             context.Context
	ApiService                      DefaultApi
	createPaymentLinkMandateRequest *CreatePaymentLinkMandateRequest
}

// request body for creating mandate for payment-link
func (r DefaultApiApiCreatePaymentLinkMandateRequest) CreatePaymentLinkMandateRequest(createPaymentLinkMandateRequest CreatePaymentLinkMandateRequest) DefaultApiApiCreatePaymentLinkMandateRequest {
	r.createPaymentLinkMandateRequest = &createPaymentLinkMandateRequest
	return r
}

func (r DefaultApiApiCreatePaymentLinkMandateRequest) Execute() (*CreatePaymentLinkMandateResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkMandateExecute(r)
}

/*
CreatePaymentLinkMandate Method for CreatePaymentLinkMandate

CREATE Mandate for payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreatePaymentLinkMandateRequest
*/
func (a *DefaultApiService) CreatePaymentLinkMandate(ctx context.Context) DefaultApiApiCreatePaymentLinkMandateRequest {
	return DefaultApiApiCreatePaymentLinkMandateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentLinkMandateResponse
func (a *DefaultApiService) CreatePaymentLinkMandateExecute(r DefaultApiApiCreatePaymentLinkMandateRequest) (*CreatePaymentLinkMandateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePaymentLinkMandateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentLinkMandate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/mandates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkMandateRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkMandateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkMandateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateScheduledPayoutRequest struct {
	ctx                          context.Context
	ApiService                   DefaultApi
	idempotencyKey               *string
	createScheduledPayoutRequest *CreateScheduledPayoutRequest
}

// A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
func (r DefaultApiApiCreateScheduledPayoutRequest) IdempotencyKey(idempotencyKey string) DefaultApiApiCreateScheduledPayoutRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Request body containing information to create scheduled payout
func (r DefaultApiApiCreateScheduledPayoutRequest) CreateScheduledPayoutRequest(createScheduledPayoutRequest CreateScheduledPayoutRequest) DefaultApiApiCreateScheduledPayoutRequest {
	r.createScheduledPayoutRequest = &createScheduledPayoutRequest
	return r
}

func (r DefaultApiApiCreateScheduledPayoutRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.CreateScheduledPayoutExecute(r)
}

/*
CreateScheduledPayout Method for CreateScheduledPayout

Create a scheduled payout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreateScheduledPayoutRequest
*/
func (a *DefaultApiService) CreateScheduledPayout(ctx context.Context) DefaultApiApiCreateScheduledPayoutRequest {
	return DefaultApiApiCreateScheduledPayoutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultApiService) CreateScheduledPayoutExecute(r DefaultApiApiCreateScheduledPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateScheduledPayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/scheduled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createScheduledPayoutRequest == nil {
		return localVarReturnValue, nil, reportError("createScheduledPayoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Idempotency-Key"] = parameterToString(*r.idempotencyKey, "")
	// body params
	localVarPostBody = r.createScheduledPayoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetFpsQrCodeRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetFpsQrCodeRequest) Execute() (*FpsQrCodeResponse, *http.Response, error) {
	return r.ApiService.GetFpsQrCodeExecute(r)
}

/*
GetFpsQrCode Method for GetFpsQrCode

Get the FPS QR code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetFpsQrCodeRequest
*/
func (a *DefaultApiService) GetFpsQrCode(ctx context.Context) DefaultApiApiGetFpsQrCodeRequest {
	return DefaultApiApiGetFpsQrCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return FpsQrCodeResponse
func (a *DefaultApiService) GetFpsQrCodeExecute(r DefaultApiApiGetFpsQrCodeRequest) (*FpsQrCodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FpsQrCodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetFpsQrCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/fps/qr_code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetInstitutionsForCustomerRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetInstitutionsForCustomerRequest) Execute() ([]Institution, *http.Response, error) {
	return r.ApiService.GetInstitutionsForCustomerExecute(r)
}

/*
GetInstitutionsForCustomer Method for GetInstitutionsForCustomer

Get a customer-specific list of institutions for Finverse Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetInstitutionsForCustomerRequest
*/
func (a *DefaultApiService) GetInstitutionsForCustomer(ctx context.Context) DefaultApiApiGetInstitutionsForCustomerRequest {
	return DefaultApiApiGetInstitutionsForCustomerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []Institution
func (a *DefaultApiService) GetInstitutionsForCustomerExecute(r DefaultApiApiGetInstitutionsForCustomerRequest) ([]Institution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Institution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetInstitutionsForCustomer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/institutions/customer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPaymentLinkRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	paymentLinkId string
}

func (r DefaultApiApiGetPaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentLinkExecute(r)
}

/*
GetPaymentLink Method for GetPaymentLink

Get payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentLinkId The payment link id
 @return DefaultApiApiGetPaymentLinkRequest
*/
func (a *DefaultApiService) GetPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiGetPaymentLinkRequest {
	return DefaultApiApiGetPaymentLinkRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentLinkId: paymentLinkId,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultApiService) GetPaymentLinkExecute(r DefaultApiApiGetPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/{paymentLinkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentLinkId"+"}", url.PathEscape(parameterToString(r.paymentLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.paymentLinkId) < 1 {
		return localVarReturnValue, nil, reportError("paymentLinkId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPayoutByIdRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	payoutId   string
}

func (r DefaultApiApiGetPayoutByIdRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.GetPayoutByIdExecute(r)
}

/*
GetPayoutById Method for GetPayoutById

Get payout by payout_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId payout id
 @return DefaultApiApiGetPayoutByIdRequest
*/
func (a *DefaultApiService) GetPayoutById(ctx context.Context, payoutId string) DefaultApiApiGetPayoutByIdRequest {
	return DefaultApiApiGetPayoutByIdRequest{
		ApiService: a,
		ctx:        ctx,
		payoutId:   payoutId,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultApiService) GetPayoutByIdExecute(r DefaultApiApiGetPayoutByIdRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPayoutById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterToString(r.payoutId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetSenderPaymentUserRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetSenderPaymentUserRequest) Execute() (*GetPaymentUserResponse, *http.Response, error) {
	return r.ApiService.GetSenderPaymentUserExecute(r)
}

/*
GetSenderPaymentUser Method for GetSenderPaymentUser

Get sender payment user in payment link flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetSenderPaymentUserRequest
*/
func (a *DefaultApiService) GetSenderPaymentUser(ctx context.Context) DefaultApiApiGetSenderPaymentUserRequest {
	return DefaultApiApiGetSenderPaymentUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetPaymentUserResponse
func (a *DefaultApiService) GetSenderPaymentUserExecute(r DefaultApiApiGetSenderPaymentUserRequest) (*GetPaymentUserResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetPaymentUserResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSenderPaymentUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_user/sender"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiListMandatesRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListMandatesRequest) DateFrom(dateFrom string) DefaultApiApiListMandatesRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListMandatesRequest) DateTo(dateTo string) DefaultApiApiListMandatesRequest {
	r.dateTo = &dateTo
	return r
}

// The mandate statuses to filter for, comma separated
func (r DefaultApiApiListMandatesRequest) Statuses(statuses []string) DefaultApiApiListMandatesRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultApiApiListMandatesRequest) SenderType(senderType string) DefaultApiApiListMandatesRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultApiApiListMandatesRequest) UserId(userId string) DefaultApiApiListMandatesRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultApiApiListMandatesRequest) InstitutionId(institutionId string) DefaultApiApiListMandatesRequest {
	r.institutionId = &institutionId
	return r
}

// default is 0
func (r DefaultApiApiListMandatesRequest) Offset(offset int32) DefaultApiApiListMandatesRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultApiApiListMandatesRequest) Limit(limit int32) DefaultApiApiListMandatesRequest {
	r.limit = &limit
	return r
}

func (r DefaultApiApiListMandatesRequest) Execute() (*ListMandatesResponse, *http.Response, error) {
	return r.ApiService.ListMandatesExecute(r)
}

/*
ListMandates Method for ListMandates

List mandates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiListMandatesRequest
*/
func (a *DefaultApiService) ListMandates(ctx context.Context) DefaultApiApiListMandatesRequest {
	return DefaultApiApiListMandatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListMandatesResponse
func (a *DefaultApiService) ListMandatesExecute(r DefaultApiApiListMandatesRequest) (*ListMandatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMandatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListMandates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, "csv"))
	}
	if r.senderType != nil {
		localVarQueryParams.Add("sender_type", parameterToString(*r.senderType, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.institutionId != nil {
		localVarQueryParams.Add("institution_id", parameterToString(*r.institutionId, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiListPaymentsRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	paymentType   *string
	mandateId     *string
	currency      *string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListPaymentsRequest) DateFrom(dateFrom string) DefaultApiApiListPaymentsRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListPaymentsRequest) DateTo(dateTo string) DefaultApiApiListPaymentsRequest {
	r.dateTo = &dateTo
	return r
}

// The payment statuses to filter for, comma separated
func (r DefaultApiApiListPaymentsRequest) Statuses(statuses []string) DefaultApiApiListPaymentsRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultApiApiListPaymentsRequest) SenderType(senderType string) DefaultApiApiListPaymentsRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultApiApiListPaymentsRequest) UserId(userId string) DefaultApiApiListPaymentsRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultApiApiListPaymentsRequest) InstitutionId(institutionId string) DefaultApiApiListPaymentsRequest {
	r.institutionId = &institutionId
	return r
}

// The type of payment
func (r DefaultApiApiListPaymentsRequest) PaymentType(paymentType string) DefaultApiApiListPaymentsRequest {
	r.paymentType = &paymentType
	return r
}

// The mandate the payment belongs to
func (r DefaultApiApiListPaymentsRequest) MandateId(mandateId string) DefaultApiApiListPaymentsRequest {
	r.mandateId = &mandateId
	return r
}

// The currency the payment is made in
func (r DefaultApiApiListPaymentsRequest) Currency(currency string) DefaultApiApiListPaymentsRequest {
	r.currency = &currency
	return r
}

// default is 0
func (r DefaultApiApiListPaymentsRequest) Offset(offset int32) DefaultApiApiListPaymentsRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultApiApiListPaymentsRequest) Limit(limit int32) DefaultApiApiListPaymentsRequest {
	r.limit = &limit
	return r
}

func (r DefaultApiApiListPaymentsRequest) Execute() (*ListPaymentsResponse, *http.Response, error) {
	return r.ApiService.ListPaymentsExecute(r)
}

/*
ListPayments Method for ListPayments

List Payments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiListPaymentsRequest
*/
func (a *DefaultApiService) ListPayments(ctx context.Context) DefaultApiApiListPaymentsRequest {
	return DefaultApiApiListPaymentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListPaymentsResponse
func (a *DefaultApiService) ListPaymentsExecute(r DefaultApiApiListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPaymentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, "csv"))
	}
	if r.senderType != nil {
		localVarQueryParams.Add("sender_type", parameterToString(*r.senderType, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.institutionId != nil {
		localVarQueryParams.Add("institution_id", parameterToString(*r.institutionId, ""))
	}
	if r.paymentType != nil {
		localVarQueryParams.Add("payment_type", parameterToString(*r.paymentType, ""))
	}
	if r.mandateId != nil {
		localVarQueryParams.Add("mandate_id", parameterToString(*r.mandateId, ""))
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiSetAutopayConsentRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	setAutopayConsentRequest *SetAutopayConsentRequest
}

func (r DefaultApiApiSetAutopayConsentRequest) SetAutopayConsentRequest(setAutopayConsentRequest SetAutopayConsentRequest) DefaultApiApiSetAutopayConsentRequest {
	r.setAutopayConsentRequest = &setAutopayConsentRequest
	return r
}

func (r DefaultApiApiSetAutopayConsentRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutopayConsentExecute(r)
}

/*
SetAutopayConsent Method for SetAutopayConsent

Set autopay consent for payment user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiSetAutopayConsentRequest
*/
func (a *DefaultApiService) SetAutopayConsent(ctx context.Context) DefaultApiApiSetAutopayConsentRequest {
	return DefaultApiApiSetAutopayConsentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) SetAutopayConsentExecute(r DefaultApiApiSetAutopayConsentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SetAutopayConsent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_user/autopay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setAutopayConsentRequest == nil {
		return nil, reportError("setAutopayConsentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setAutopayConsentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
