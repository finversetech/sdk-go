/*
Finverse Public

Documentation of the early finverse services

API version: 0.0.1
Contact: info@finverse.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package finverse

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type DefaultApi interface {

	/*
		CancelPaymentLink Method for CancelPaymentLink

		Cancel a payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentLinkId The payment link id
		 @return DefaultApiApiCancelPaymentLinkRequest
	*/
	CancelPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiCancelPaymentLinkRequest

	// CancelPaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	CancelPaymentLinkExecute(r DefaultApiApiCancelPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		CancelPaymentPaymentLink Method for CancelPaymentPaymentLink

		cancel payment on payment link (Deprecated, should use unlink instead)

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCancelPaymentPaymentLinkRequest
	*/
	CancelPaymentPaymentLink(ctx context.Context) DefaultApiApiCancelPaymentPaymentLinkRequest

	// CancelPaymentPaymentLinkExecute executes the request
	CancelPaymentPaymentLinkExecute(r DefaultApiApiCancelPaymentPaymentLinkRequest) (*http.Response, error)

	/*
		CancelPayout Method for CancelPayout

		Cancel Payout by payout_id

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param payoutId payout id
		 @return DefaultApiApiCancelPayoutRequest
	*/
	CancelPayout(ctx context.Context, payoutId string) DefaultApiApiCancelPayoutRequest

	// CancelPayoutExecute executes the request
	//  @return PayoutSnapshotResponse
	CancelPayoutExecute(r DefaultApiApiCancelPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		ChangePaymentMethodPaymentLink Method for ChangePaymentMethodPaymentLink

		Initiate change payment method from payment link front-end

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiChangePaymentMethodPaymentLinkRequest
	*/
	ChangePaymentMethodPaymentLink(ctx context.Context) DefaultApiApiChangePaymentMethodPaymentLinkRequest

	// ChangePaymentMethodPaymentLinkExecute executes the request
	//  @return ChangePaymentMethodFvLinkResponse
	ChangePaymentMethodPaymentLinkExecute(r DefaultApiApiChangePaymentMethodPaymentLinkRequest) (*ChangePaymentMethodFvLinkResponse, *http.Response, error)

	/*
		ConfirmManualPayment Method for ConfirmManualPayment

		Submit manual payment confirmation

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiConfirmManualPaymentRequest
	*/
	ConfirmManualPayment(ctx context.Context) DefaultApiApiConfirmManualPaymentRequest

	// ConfirmManualPaymentExecute executes the request
	//  @return ManualPaymentConfirmationResponse
	ConfirmManualPaymentExecute(r DefaultApiApiConfirmManualPaymentRequest) (*ManualPaymentConfirmationResponse, *http.Response, error)

	/*
		ConfirmPayment Method for ConfirmPayment

		Confirm a payment against a payment Link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiConfirmPaymentRequest
	*/
	ConfirmPayment(ctx context.Context) DefaultApiApiConfirmPaymentRequest

	// ConfirmPaymentExecute executes the request
	//  @return ConfirmPaymentResponse
	ConfirmPaymentExecute(r DefaultApiApiConfirmPaymentRequest) (*ConfirmPaymentResponse, *http.Response, error)

	/*
		CreateFpsToken Method for CreateFpsToken

		Create token for fps flow

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreateFpsTokenRequest
	*/
	CreateFpsToken(ctx context.Context) DefaultApiApiCreateFpsTokenRequest

	// CreateFpsTokenExecute executes the request
	//  @return CreateFpsTokenResponse
	CreateFpsTokenExecute(r DefaultApiApiCreateFpsTokenRequest) (*CreateFpsTokenResponse, *http.Response, error)

	/*
		CreateMandateForExistingSender Method for CreateMandateForExistingSender

		Create mandate for an existing sender account

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreateMandateForExistingSenderRequest
	*/
	CreateMandateForExistingSender(ctx context.Context) DefaultApiApiCreateMandateForExistingSenderRequest

	// CreateMandateForExistingSenderExecute executes the request
	//  @return CreateMandateResponse
	CreateMandateForExistingSenderExecute(r DefaultApiApiCreateMandateForExistingSenderRequest) (*CreateMandateResponse, *http.Response, error)

	/*
		CreatePaymentLink Method for CreatePaymentLink

		Create payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreatePaymentLinkRequest
	*/
	CreatePaymentLink(ctx context.Context) DefaultApiApiCreatePaymentLinkRequest

	// CreatePaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	CreatePaymentLinkExecute(r DefaultApiApiCreatePaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		CreatePaymentLinkCardPayment Method for CreatePaymentLinkCardPayment

		Initiate Card Payment for a Payment Link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreatePaymentLinkCardPaymentRequest
	*/
	CreatePaymentLinkCardPayment(ctx context.Context) DefaultApiApiCreatePaymentLinkCardPaymentRequest

	// CreatePaymentLinkCardPaymentExecute executes the request
	//  @return CreatePaymentLinkCardPaymentResponse
	CreatePaymentLinkCardPaymentExecute(r DefaultApiApiCreatePaymentLinkCardPaymentRequest) (*CreatePaymentLinkCardPaymentResponse, *http.Response, error)

	/*
		CreatePaymentLinkMandate Method for CreatePaymentLinkMandate

		CREATE Mandate for payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreatePaymentLinkMandateRequest
	*/
	CreatePaymentLinkMandate(ctx context.Context) DefaultApiApiCreatePaymentLinkMandateRequest

	// CreatePaymentLinkMandateExecute executes the request
	//  @return CreatePaymentLinkMandateResponse
	CreatePaymentLinkMandateExecute(r DefaultApiApiCreatePaymentLinkMandateRequest) (*CreatePaymentLinkMandateResponse, *http.Response, error)

	/*
		CreatePaymentMethod Method for CreatePaymentMethod

		Create a Payment Method for a user

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentUserId Payment User ID
		 @return DefaultApiApiCreatePaymentMethodRequest
	*/
	CreatePaymentMethod(ctx context.Context, paymentUserId string) DefaultApiApiCreatePaymentMethodRequest

	// CreatePaymentMethodExecute executes the request
	//  @return PaymentMethodResponse
	CreatePaymentMethodExecute(r DefaultApiApiCreatePaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error)

	/*
		CreateScheduledPayout Method for CreateScheduledPayout

		Create a scheduled payout

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiCreateScheduledPayoutRequest
	*/
	CreateScheduledPayout(ctx context.Context) DefaultApiApiCreateScheduledPayoutRequest

	// CreateScheduledPayoutExecute executes the request
	//  @return PayoutSnapshotResponse
	CreateScheduledPayoutExecute(r DefaultApiApiCreateScheduledPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		DownloadBalanceStatement Method for DownloadBalanceStatement

		Download the balance statement for the ledger (CSV)

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiDownloadBalanceStatementRequest
	*/
	DownloadBalanceStatement(ctx context.Context) DefaultApiApiDownloadBalanceStatementRequest

	// DownloadBalanceStatementExecute executes the request
	//  @return DownloadBalanceStatementResponse
	DownloadBalanceStatementExecute(r DefaultApiApiDownloadBalanceStatementRequest) (*DownloadBalanceStatementResponse, *http.Response, error)

	/*
		GetFpsQrCode Method for GetFpsQrCode

		Get the FPS QR code

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetFpsQrCodeRequest
	*/
	GetFpsQrCode(ctx context.Context) DefaultApiApiGetFpsQrCodeRequest

	// GetFpsQrCodeExecute executes the request
	//  @return FpsQrCodeResponse
	GetFpsQrCodeExecute(r DefaultApiApiGetFpsQrCodeRequest) (*FpsQrCodeResponse, *http.Response, error)

	/*
		GetInstitutionsForCustomer Method for GetInstitutionsForCustomer

		Get a customer-specific list of institutions for Finverse Link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetInstitutionsForCustomerRequest
	*/
	GetInstitutionsForCustomer(ctx context.Context) DefaultApiApiGetInstitutionsForCustomerRequest

	// GetInstitutionsForCustomerExecute executes the request
	//  @return []Institution
	GetInstitutionsForCustomerExecute(r DefaultApiApiGetInstitutionsForCustomerRequest) ([]Institution, *http.Response, error)

	/*
		GetPaymentLink Method for GetPaymentLink

		Get payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentLinkId The payment link id
		 @return DefaultApiApiGetPaymentLinkRequest
	*/
	GetPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiGetPaymentLinkRequest

	// GetPaymentLinkExecute executes the request
	//  @return PaymentLinkResponse
	GetPaymentLinkExecute(r DefaultApiApiGetPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error)

	/*
		GetPaymentMethod Method for GetPaymentMethod

		Get a payment method

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentMethodId
		 @return DefaultApiApiGetPaymentMethodRequest
	*/
	GetPaymentMethod(ctx context.Context, paymentMethodId string) DefaultApiApiGetPaymentMethodRequest

	// GetPaymentMethodExecute executes the request
	//  @return PaymentMethodResponse
	GetPaymentMethodExecute(r DefaultApiApiGetPaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error)

	/*
		GetPaymentMethodPaymentLink Method for GetPaymentMethodPaymentLink

		Get payment method in payment link flow

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetPaymentMethodPaymentLinkRequest
	*/
	GetPaymentMethodPaymentLink(ctx context.Context) DefaultApiApiGetPaymentMethodPaymentLinkRequest

	// GetPaymentMethodPaymentLinkExecute executes the request
	//  @return PaymentMethodFvLinkResponse
	GetPaymentMethodPaymentLinkExecute(r DefaultApiApiGetPaymentMethodPaymentLinkRequest) (*PaymentMethodFvLinkResponse, *http.Response, error)

	/*
		GetPaymentPaymentLink Method for GetPaymentPaymentLink

		Get payment (if exists) on the payment link for front-end

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetPaymentPaymentLinkRequest
	*/
	GetPaymentPaymentLink(ctx context.Context) DefaultApiApiGetPaymentPaymentLinkRequest

	// GetPaymentPaymentLinkExecute executes the request
	//  @return PaymentFvLinkResponse
	GetPaymentPaymentLinkExecute(r DefaultApiApiGetPaymentPaymentLinkRequest) (*PaymentFvLinkResponse, *http.Response, error)

	/*
		GetPayoutById Method for GetPayoutById

		Get payout by payout_id

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param payoutId payout id
		 @return DefaultApiApiGetPayoutByIdRequest
	*/
	GetPayoutById(ctx context.Context, payoutId string) DefaultApiApiGetPayoutByIdRequest

	// GetPayoutByIdExecute executes the request
	//  @return PayoutSnapshotResponse
	GetPayoutByIdExecute(r DefaultApiApiGetPayoutByIdRequest) (*PayoutSnapshotResponse, *http.Response, error)

	/*
		GetSenderPaymentUser Method for GetSenderPaymentUser

		Get sender payment user in payment link flow

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiGetSenderPaymentUserRequest
	*/
	GetSenderPaymentUser(ctx context.Context) DefaultApiApiGetSenderPaymentUserRequest

	// GetSenderPaymentUserExecute executes the request
	//  @return GetPaymentUserResponse
	GetSenderPaymentUserExecute(r DefaultApiApiGetSenderPaymentUserRequest) (*GetPaymentUserResponse, *http.Response, error)

	/*
		ListDetokenizedMandates Method for ListDetokenizedMandates

		List mandates details

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiListDetokenizedMandatesRequest
	*/
	ListDetokenizedMandates(ctx context.Context) DefaultApiApiListDetokenizedMandatesRequest

	// ListDetokenizedMandatesExecute executes the request
	//  @return ListMandatesResponse
	ListDetokenizedMandatesExecute(r DefaultApiApiListDetokenizedMandatesRequest) (*ListMandatesResponse, *http.Response, error)

	/*
		ListMandates Method for ListMandates

		List mandates

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiListMandatesRequest
	*/
	ListMandates(ctx context.Context) DefaultApiApiListMandatesRequest

	// ListMandatesExecute executes the request
	//  @return ListMandatesResponse
	ListMandatesExecute(r DefaultApiApiListMandatesRequest) (*ListMandatesResponse, *http.Response, error)

	/*
		ListPaymentMethods Method for ListPaymentMethods

		List Payment Methods for a User

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentUserId Payment User Id
		 @return DefaultApiApiListPaymentMethodsRequest
	*/
	ListPaymentMethods(ctx context.Context, paymentUserId string) DefaultApiApiListPaymentMethodsRequest

	// ListPaymentMethodsExecute executes the request
	//  @return ListPaymentMethodsResponse
	ListPaymentMethodsExecute(r DefaultApiApiListPaymentMethodsRequest) (*ListPaymentMethodsResponse, *http.Response, error)

	/*
		ListPayments Method for ListPayments

		List Payments

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiListPaymentsRequest
	*/
	ListPayments(ctx context.Context) DefaultApiApiListPaymentsRequest

	// ListPaymentsExecute executes the request
	//  @return ListPaymentsResponse
	ListPaymentsExecute(r DefaultApiApiListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error)

	/*
		RefreshPaymentAttempt Method for RefreshPaymentAttempt

		Refresh payment attempt from payment link front-end

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiRefreshPaymentAttemptRequest
	*/
	RefreshPaymentAttempt(ctx context.Context) DefaultApiApiRefreshPaymentAttemptRequest

	// RefreshPaymentAttemptExecute executes the request
	//  @return RefreshPaymentAttemptResponse
	RefreshPaymentAttemptExecute(r DefaultApiApiRefreshPaymentAttemptRequest) (*RefreshPaymentAttemptResponse, *http.Response, error)

	/*
		SetAutopayConsent Method for SetAutopayConsent

		Set autopay consent for payment user

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiSetAutopayConsentRequest
	*/
	SetAutopayConsent(ctx context.Context) DefaultApiApiSetAutopayConsentRequest

	// SetAutopayConsentExecute executes the request
	SetAutopayConsentExecute(r DefaultApiApiSetAutopayConsentRequest) (*http.Response, error)

	/*
		UnlinkPaymentPaymentLink Method for UnlinkPaymentPaymentLink

		Unlink payment on payment link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return DefaultApiApiUnlinkPaymentPaymentLinkRequest
	*/
	UnlinkPaymentPaymentLink(ctx context.Context) DefaultApiApiUnlinkPaymentPaymentLinkRequest

	// UnlinkPaymentPaymentLinkExecute executes the request
	UnlinkPaymentPaymentLinkExecute(r DefaultApiApiUnlinkPaymentPaymentLinkRequest) (*http.Response, error)

	/*
		UpdatePaymentUser Method for UpdatePaymentUser

		Update a payment user

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param paymentUserId
		 @return DefaultApiApiUpdatePaymentUserRequest
	*/
	UpdatePaymentUser(ctx context.Context, paymentUserId string) DefaultApiApiUpdatePaymentUserRequest

	// UpdatePaymentUserExecute executes the request
	//  @return PaymentUser
	UpdatePaymentUserExecute(r DefaultApiApiUpdatePaymentUserRequest) (*PaymentUser, *http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiApiCancelPaymentLinkRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	paymentLinkId string
}

func (r DefaultApiApiCancelPaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.CancelPaymentLinkExecute(r)
}

/*
CancelPaymentLink Method for CancelPaymentLink

Cancel a payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentLinkId The payment link id
 @return DefaultApiApiCancelPaymentLinkRequest
*/
func (a *DefaultApiService) CancelPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiCancelPaymentLinkRequest {
	return DefaultApiApiCancelPaymentLinkRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentLinkId: paymentLinkId,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultApiService) CancelPaymentLinkExecute(r DefaultApiApiCancelPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CancelPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/{paymentLinkId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentLinkId"+"}", url.PathEscape(parameterToString(r.paymentLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.paymentLinkId) < 1 {
		return localVarReturnValue, nil, reportError("paymentLinkId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCancelPaymentPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiCancelPaymentPaymentLinkRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelPaymentPaymentLinkExecute(r)
}

/*
CancelPaymentPaymentLink Method for CancelPaymentPaymentLink

cancel payment on payment link (Deprecated, should use unlink instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCancelPaymentPaymentLinkRequest
*/
func (a *DefaultApiService) CancelPaymentPaymentLink(ctx context.Context) DefaultApiApiCancelPaymentPaymentLinkRequest {
	return DefaultApiApiCancelPaymentPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) CancelPaymentPaymentLinkExecute(r DefaultApiApiCancelPaymentPaymentLinkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CancelPaymentPaymentLink")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiCancelPayoutRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	payoutId   string
}

func (r DefaultApiApiCancelPayoutRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.CancelPayoutExecute(r)
}

/*
CancelPayout Method for CancelPayout

Cancel Payout by payout_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId payout id
 @return DefaultApiApiCancelPayoutRequest
*/
func (a *DefaultApiService) CancelPayout(ctx context.Context, payoutId string) DefaultApiApiCancelPayoutRequest {
	return DefaultApiApiCancelPayoutRequest{
		ApiService: a,
		ctx:        ctx,
		payoutId:   payoutId,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultApiService) CancelPayoutExecute(r DefaultApiApiCancelPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CancelPayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterToString(r.payoutId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiChangePaymentMethodPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiChangePaymentMethodPaymentLinkRequest) Execute() (*ChangePaymentMethodFvLinkResponse, *http.Response, error) {
	return r.ApiService.ChangePaymentMethodPaymentLinkExecute(r)
}

/*
ChangePaymentMethodPaymentLink Method for ChangePaymentMethodPaymentLink

Initiate change payment method from payment link front-end

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiChangePaymentMethodPaymentLinkRequest
*/
func (a *DefaultApiService) ChangePaymentMethodPaymentLink(ctx context.Context) DefaultApiApiChangePaymentMethodPaymentLinkRequest {
	return DefaultApiApiChangePaymentMethodPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ChangePaymentMethodFvLinkResponse
func (a *DefaultApiService) ChangePaymentMethodPaymentLinkExecute(r DefaultApiApiChangePaymentMethodPaymentLinkRequest) (*ChangePaymentMethodFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChangePaymentMethodFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ChangePaymentMethodPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_method/change"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiConfirmManualPaymentRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	manualPaymentIdentifiers *ManualPaymentConfirmationRequest
}

// Request body containing information to identify manual payment
func (r DefaultApiApiConfirmManualPaymentRequest) ManualPaymentIdentifiers(manualPaymentIdentifiers ManualPaymentConfirmationRequest) DefaultApiApiConfirmManualPaymentRequest {
	r.manualPaymentIdentifiers = &manualPaymentIdentifiers
	return r
}

func (r DefaultApiApiConfirmManualPaymentRequest) Execute() (*ManualPaymentConfirmationResponse, *http.Response, error) {
	return r.ApiService.ConfirmManualPaymentExecute(r)
}

/*
ConfirmManualPayment Method for ConfirmManualPayment

Submit manual payment confirmation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiConfirmManualPaymentRequest
*/
func (a *DefaultApiService) ConfirmManualPayment(ctx context.Context) DefaultApiApiConfirmManualPaymentRequest {
	return DefaultApiApiConfirmManualPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ManualPaymentConfirmationResponse
func (a *DefaultApiService) ConfirmManualPaymentExecute(r DefaultApiApiConfirmManualPaymentRequest) (*ManualPaymentConfirmationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManualPaymentConfirmationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConfirmManualPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/manual_payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.manualPaymentIdentifiers == nil {
		return localVarReturnValue, nil, reportError("manualPaymentIdentifiers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manualPaymentIdentifiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiConfirmPaymentRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiConfirmPaymentRequest) Execute() (*ConfirmPaymentResponse, *http.Response, error) {
	return r.ApiService.ConfirmPaymentExecute(r)
}

/*
ConfirmPayment Method for ConfirmPayment

Confirm a payment against a payment Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiConfirmPaymentRequest
*/
func (a *DefaultApiService) ConfirmPayment(ctx context.Context) DefaultApiApiConfirmPaymentRequest {
	return DefaultApiApiConfirmPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ConfirmPaymentResponse
func (a *DefaultApiService) ConfirmPaymentExecute(r DefaultApiApiConfirmPaymentRequest) (*ConfirmPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfirmPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConfirmPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateFpsTokenRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiCreateFpsTokenRequest) Execute() (*CreateFpsTokenResponse, *http.Response, error) {
	return r.ApiService.CreateFpsTokenExecute(r)
}

/*
CreateFpsToken Method for CreateFpsToken

Create token for fps flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreateFpsTokenRequest
*/
func (a *DefaultApiService) CreateFpsToken(ctx context.Context) DefaultApiApiCreateFpsTokenRequest {
	return DefaultApiApiCreateFpsTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreateFpsTokenResponse
func (a *DefaultApiService) CreateFpsTokenExecute(r DefaultApiApiCreateFpsTokenRequest) (*CreateFpsTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateFpsTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateFpsToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/fps/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateMandateForExistingSenderRequest struct {
	ctx                  context.Context
	ApiService           DefaultApi
	idempotencyKey       *string
	createMandateRequest *CreateMandateWithSenderAccountRequest
}

// A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
func (r DefaultApiApiCreateMandateForExistingSenderRequest) IdempotencyKey(idempotencyKey string) DefaultApiApiCreateMandateForExistingSenderRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// request body for creating mandate
func (r DefaultApiApiCreateMandateForExistingSenderRequest) CreateMandateRequest(createMandateRequest CreateMandateWithSenderAccountRequest) DefaultApiApiCreateMandateForExistingSenderRequest {
	r.createMandateRequest = &createMandateRequest
	return r
}

func (r DefaultApiApiCreateMandateForExistingSenderRequest) Execute() (*CreateMandateResponse, *http.Response, error) {
	return r.ApiService.CreateMandateForExistingSenderExecute(r)
}

/*
CreateMandateForExistingSender Method for CreateMandateForExistingSender

Create mandate for an existing sender account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreateMandateForExistingSenderRequest
*/
func (a *DefaultApiService) CreateMandateForExistingSender(ctx context.Context) DefaultApiApiCreateMandateForExistingSenderRequest {
	return DefaultApiApiCreateMandateForExistingSenderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreateMandateResponse
func (a *DefaultApiService) CreateMandateForExistingSenderExecute(r DefaultApiApiCreateMandateForExistingSenderRequest) (*CreateMandateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateMandateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMandateForExistingSender")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates/sender_account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createMandateRequest == nil {
		return localVarReturnValue, nil, reportError("createMandateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Idempotency-Key"] = parameterToString(*r.idempotencyKey, "")
	// body params
	localVarPostBody = r.createMandateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentLinkRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	createPaymentLinkRequest *CreatePaymentLinkRequest
}

// Parameters required to create a payment link
func (r DefaultApiApiCreatePaymentLinkRequest) CreatePaymentLinkRequest(createPaymentLinkRequest CreatePaymentLinkRequest) DefaultApiApiCreatePaymentLinkRequest {
	r.createPaymentLinkRequest = &createPaymentLinkRequest
	return r
}

func (r DefaultApiApiCreatePaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkExecute(r)
}

/*
CreatePaymentLink Method for CreatePaymentLink

Create payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreatePaymentLinkRequest
*/
func (a *DefaultApiService) CreatePaymentLink(ctx context.Context) DefaultApiApiCreatePaymentLinkRequest {
	return DefaultApiApiCreatePaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultApiService) CreatePaymentLinkExecute(r DefaultApiApiCreatePaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentLinkCardPaymentRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiCreatePaymentLinkCardPaymentRequest) Execute() (*CreatePaymentLinkCardPaymentResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkCardPaymentExecute(r)
}

/*
CreatePaymentLinkCardPayment Method for CreatePaymentLinkCardPayment

Initiate Card Payment for a Payment Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreatePaymentLinkCardPaymentRequest
*/
func (a *DefaultApiService) CreatePaymentLinkCardPayment(ctx context.Context) DefaultApiApiCreatePaymentLinkCardPaymentRequest {
	return DefaultApiApiCreatePaymentLinkCardPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentLinkCardPaymentResponse
func (a *DefaultApiService) CreatePaymentLinkCardPaymentExecute(r DefaultApiApiCreatePaymentLinkCardPaymentRequest) (*CreatePaymentLinkCardPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePaymentLinkCardPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentLinkCardPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/card"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentLinkMandateRequest struct {
	ctx                             context.Context
	ApiService                      DefaultApi
	createPaymentLinkMandateRequest *CreatePaymentLinkMandateRequest
}

// request body for creating mandate for payment-link
func (r DefaultApiApiCreatePaymentLinkMandateRequest) CreatePaymentLinkMandateRequest(createPaymentLinkMandateRequest CreatePaymentLinkMandateRequest) DefaultApiApiCreatePaymentLinkMandateRequest {
	r.createPaymentLinkMandateRequest = &createPaymentLinkMandateRequest
	return r
}

func (r DefaultApiApiCreatePaymentLinkMandateRequest) Execute() (*CreatePaymentLinkMandateResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentLinkMandateExecute(r)
}

/*
CreatePaymentLinkMandate Method for CreatePaymentLinkMandate

CREATE Mandate for payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreatePaymentLinkMandateRequest
*/
func (a *DefaultApiService) CreatePaymentLinkMandate(ctx context.Context) DefaultApiApiCreatePaymentLinkMandateRequest {
	return DefaultApiApiCreatePaymentLinkMandateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentLinkMandateResponse
func (a *DefaultApiService) CreatePaymentLinkMandateExecute(r DefaultApiApiCreatePaymentLinkMandateRequest) (*CreatePaymentLinkMandateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePaymentLinkMandateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentLinkMandate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/mandates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentLinkMandateRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentLinkMandateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentLinkMandateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePaymentMethodRequest struct {
	ctx                        context.Context
	ApiService                 DefaultApi
	paymentUserId              string
	createPaymentMethodRequest *CreatePaymentMethodRequest
}

func (r DefaultApiApiCreatePaymentMethodRequest) CreatePaymentMethodRequest(createPaymentMethodRequest CreatePaymentMethodRequest) DefaultApiApiCreatePaymentMethodRequest {
	r.createPaymentMethodRequest = &createPaymentMethodRequest
	return r
}

func (r DefaultApiApiCreatePaymentMethodRequest) Execute() (*PaymentMethodResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentMethodExecute(r)
}

/*
CreatePaymentMethod Method for CreatePaymentMethod

Create a Payment Method for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentUserId Payment User ID
 @return DefaultApiApiCreatePaymentMethodRequest
*/
func (a *DefaultApiService) CreatePaymentMethod(ctx context.Context, paymentUserId string) DefaultApiApiCreatePaymentMethodRequest {
	return DefaultApiApiCreatePaymentMethodRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentUserId: paymentUserId,
	}
}

// Execute executes the request
//  @return PaymentMethodResponse
func (a *DefaultApiService) CreatePaymentMethodExecute(r DefaultApiApiCreatePaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentMethodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_users/{paymentUserId}/payment_methods"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentUserId"+"}", url.PathEscape(parameterToString(r.paymentUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPaymentMethodRequest == nil {
		return localVarReturnValue, nil, reportError("createPaymentMethodRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPaymentMethodRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateScheduledPayoutRequest struct {
	ctx                          context.Context
	ApiService                   DefaultApi
	idempotencyKey               *string
	createScheduledPayoutRequest *CreateScheduledPayoutRequest
}

// A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
func (r DefaultApiApiCreateScheduledPayoutRequest) IdempotencyKey(idempotencyKey string) DefaultApiApiCreateScheduledPayoutRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Request body containing information to create scheduled payout
func (r DefaultApiApiCreateScheduledPayoutRequest) CreateScheduledPayoutRequest(createScheduledPayoutRequest CreateScheduledPayoutRequest) DefaultApiApiCreateScheduledPayoutRequest {
	r.createScheduledPayoutRequest = &createScheduledPayoutRequest
	return r
}

func (r DefaultApiApiCreateScheduledPayoutRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.CreateScheduledPayoutExecute(r)
}

/*
CreateScheduledPayout Method for CreateScheduledPayout

Create a scheduled payout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiCreateScheduledPayoutRequest
*/
func (a *DefaultApiService) CreateScheduledPayout(ctx context.Context) DefaultApiApiCreateScheduledPayoutRequest {
	return DefaultApiApiCreateScheduledPayoutRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultApiService) CreateScheduledPayoutExecute(r DefaultApiApiCreateScheduledPayoutRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateScheduledPayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/scheduled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createScheduledPayoutRequest == nil {
		return localVarReturnValue, nil, reportError("createScheduledPayoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Idempotency-Key"] = parameterToString(*r.idempotencyKey, "")
	// body params
	localVarPostBody = r.createScheduledPayoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiDownloadBalanceStatementRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	dateFrom   *string
	dateTo     *string
	currencies *[]string
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiDownloadBalanceStatementRequest) DateFrom(dateFrom string) DefaultApiApiDownloadBalanceStatementRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiDownloadBalanceStatementRequest) DateTo(dateTo string) DefaultApiApiDownloadBalanceStatementRequest {
	r.dateTo = &dateTo
	return r
}

// The currencies to filter for
func (r DefaultApiApiDownloadBalanceStatementRequest) Currencies(currencies []string) DefaultApiApiDownloadBalanceStatementRequest {
	r.currencies = &currencies
	return r
}

func (r DefaultApiApiDownloadBalanceStatementRequest) Execute() (*DownloadBalanceStatementResponse, *http.Response, error) {
	return r.ApiService.DownloadBalanceStatementExecute(r)
}

/*
DownloadBalanceStatement Method for DownloadBalanceStatement

Download the balance statement for the ledger (CSV)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiDownloadBalanceStatementRequest
*/
func (a *DefaultApiService) DownloadBalanceStatement(ctx context.Context) DefaultApiApiDownloadBalanceStatementRequest {
	return DefaultApiApiDownloadBalanceStatementRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DownloadBalanceStatementResponse
func (a *DefaultApiService) DownloadBalanceStatementExecute(r DefaultApiApiDownloadBalanceStatementRequest) (*DownloadBalanceStatementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DownloadBalanceStatementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DownloadBalanceStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ledger/statement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.currencies != nil {
		localVarQueryParams.Add("currencies", parameterToString(*r.currencies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetFpsQrCodeRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetFpsQrCodeRequest) Execute() (*FpsQrCodeResponse, *http.Response, error) {
	return r.ApiService.GetFpsQrCodeExecute(r)
}

/*
GetFpsQrCode Method for GetFpsQrCode

Get the FPS QR code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetFpsQrCodeRequest
*/
func (a *DefaultApiService) GetFpsQrCode(ctx context.Context) DefaultApiApiGetFpsQrCodeRequest {
	return DefaultApiApiGetFpsQrCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return FpsQrCodeResponse
func (a *DefaultApiService) GetFpsQrCodeExecute(r DefaultApiApiGetFpsQrCodeRequest) (*FpsQrCodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FpsQrCodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetFpsQrCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/fps/qr_code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetInstitutionsForCustomerRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetInstitutionsForCustomerRequest) Execute() ([]Institution, *http.Response, error) {
	return r.ApiService.GetInstitutionsForCustomerExecute(r)
}

/*
GetInstitutionsForCustomer Method for GetInstitutionsForCustomer

Get a customer-specific list of institutions for Finverse Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetInstitutionsForCustomerRequest
*/
func (a *DefaultApiService) GetInstitutionsForCustomer(ctx context.Context) DefaultApiApiGetInstitutionsForCustomerRequest {
	return DefaultApiApiGetInstitutionsForCustomerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []Institution
func (a *DefaultApiService) GetInstitutionsForCustomerExecute(r DefaultApiApiGetInstitutionsForCustomerRequest) ([]Institution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Institution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetInstitutionsForCustomer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/institutions/customer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPaymentLinkRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	paymentLinkId string
}

func (r DefaultApiApiGetPaymentLinkRequest) Execute() (*PaymentLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentLinkExecute(r)
}

/*
GetPaymentLink Method for GetPaymentLink

Get payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentLinkId The payment link id
 @return DefaultApiApiGetPaymentLinkRequest
*/
func (a *DefaultApiService) GetPaymentLink(ctx context.Context, paymentLinkId string) DefaultApiApiGetPaymentLinkRequest {
	return DefaultApiApiGetPaymentLinkRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentLinkId: paymentLinkId,
	}
}

// Execute executes the request
//  @return PaymentLinkResponse
func (a *DefaultApiService) GetPaymentLinkExecute(r DefaultApiApiGetPaymentLinkRequest) (*PaymentLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_links/{paymentLinkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentLinkId"+"}", url.PathEscape(parameterToString(r.paymentLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.paymentLinkId) < 1 {
		return localVarReturnValue, nil, reportError("paymentLinkId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPaymentMethodRequest struct {
	ctx             context.Context
	ApiService      DefaultApi
	paymentMethodId string
}

func (r DefaultApiApiGetPaymentMethodRequest) Execute() (*PaymentMethodResponse, *http.Response, error) {
	return r.ApiService.GetPaymentMethodExecute(r)
}

/*
GetPaymentMethod Method for GetPaymentMethod

Get a payment method

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentMethodId
 @return DefaultApiApiGetPaymentMethodRequest
*/
func (a *DefaultApiService) GetPaymentMethod(ctx context.Context, paymentMethodId string) DefaultApiApiGetPaymentMethodRequest {
	return DefaultApiApiGetPaymentMethodRequest{
		ApiService:      a,
		ctx:             ctx,
		paymentMethodId: paymentMethodId,
	}
}

// Execute executes the request
//  @return PaymentMethodResponse
func (a *DefaultApiService) GetPaymentMethodExecute(r DefaultApiApiGetPaymentMethodRequest) (*PaymentMethodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentMethodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_methods/{paymentMethodId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentMethodId"+"}", url.PathEscape(parameterToString(r.paymentMethodId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPaymentMethodPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetPaymentMethodPaymentLinkRequest) Execute() (*PaymentMethodFvLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentMethodPaymentLinkExecute(r)
}

/*
GetPaymentMethodPaymentLink Method for GetPaymentMethodPaymentLink

Get payment method in payment link flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetPaymentMethodPaymentLinkRequest
*/
func (a *DefaultApiService) GetPaymentMethodPaymentLink(ctx context.Context) DefaultApiApiGetPaymentMethodPaymentLinkRequest {
	return DefaultApiApiGetPaymentMethodPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentMethodFvLinkResponse
func (a *DefaultApiService) GetPaymentMethodPaymentLinkExecute(r DefaultApiApiGetPaymentMethodPaymentLinkRequest) (*PaymentMethodFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentMethodFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentMethodPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_method"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPaymentPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetPaymentPaymentLinkRequest) Execute() (*PaymentFvLinkResponse, *http.Response, error) {
	return r.ApiService.GetPaymentPaymentLinkExecute(r)
}

/*
GetPaymentPaymentLink Method for GetPaymentPaymentLink

Get payment (if exists) on the payment link for front-end

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetPaymentPaymentLinkRequest
*/
func (a *DefaultApiService) GetPaymentPaymentLink(ctx context.Context) DefaultApiApiGetPaymentPaymentLinkRequest {
	return DefaultApiApiGetPaymentPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaymentFvLinkResponse
func (a *DefaultApiService) GetPaymentPaymentLinkExecute(r DefaultApiApiGetPaymentPaymentLinkRequest) (*PaymentFvLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentFvLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPaymentPaymentLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPayoutByIdRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	payoutId   string
}

func (r DefaultApiApiGetPayoutByIdRequest) Execute() (*PayoutSnapshotResponse, *http.Response, error) {
	return r.ApiService.GetPayoutByIdExecute(r)
}

/*
GetPayoutById Method for GetPayoutById

Get payout by payout_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId payout id
 @return DefaultApiApiGetPayoutByIdRequest
*/
func (a *DefaultApiService) GetPayoutById(ctx context.Context, payoutId string) DefaultApiApiGetPayoutByIdRequest {
	return DefaultApiApiGetPayoutByIdRequest{
		ApiService: a,
		ctx:        ctx,
		payoutId:   payoutId,
	}
}

// Execute executes the request
//  @return PayoutSnapshotResponse
func (a *DefaultApiService) GetPayoutByIdExecute(r DefaultApiApiGetPayoutByIdRequest) (*PayoutSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PayoutSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPayoutById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterToString(r.payoutId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetSenderPaymentUserRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiGetSenderPaymentUserRequest) Execute() (*GetPaymentUserResponse, *http.Response, error) {
	return r.ApiService.GetSenderPaymentUserExecute(r)
}

/*
GetSenderPaymentUser Method for GetSenderPaymentUser

Get sender payment user in payment link flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiGetSenderPaymentUserRequest
*/
func (a *DefaultApiService) GetSenderPaymentUser(ctx context.Context) DefaultApiApiGetSenderPaymentUserRequest {
	return DefaultApiApiGetSenderPaymentUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetPaymentUserResponse
func (a *DefaultApiService) GetSenderPaymentUserExecute(r DefaultApiApiGetSenderPaymentUserRequest) (*GetPaymentUserResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetPaymentUserResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSenderPaymentUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_user/sender"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiListDetokenizedMandatesRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListDetokenizedMandatesRequest) DateFrom(dateFrom string) DefaultApiApiListDetokenizedMandatesRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListDetokenizedMandatesRequest) DateTo(dateTo string) DefaultApiApiListDetokenizedMandatesRequest {
	r.dateTo = &dateTo
	return r
}

// The mandate statuses to filter for, comma separated
func (r DefaultApiApiListDetokenizedMandatesRequest) Statuses(statuses []string) DefaultApiApiListDetokenizedMandatesRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultApiApiListDetokenizedMandatesRequest) SenderType(senderType string) DefaultApiApiListDetokenizedMandatesRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultApiApiListDetokenizedMandatesRequest) UserId(userId string) DefaultApiApiListDetokenizedMandatesRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultApiApiListDetokenizedMandatesRequest) InstitutionId(institutionId string) DefaultApiApiListDetokenizedMandatesRequest {
	r.institutionId = &institutionId
	return r
}

// default is 0
func (r DefaultApiApiListDetokenizedMandatesRequest) Offset(offset int32) DefaultApiApiListDetokenizedMandatesRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultApiApiListDetokenizedMandatesRequest) Limit(limit int32) DefaultApiApiListDetokenizedMandatesRequest {
	r.limit = &limit
	return r
}

func (r DefaultApiApiListDetokenizedMandatesRequest) Execute() (*ListMandatesResponse, *http.Response, error) {
	return r.ApiService.ListDetokenizedMandatesExecute(r)
}

/*
ListDetokenizedMandates Method for ListDetokenizedMandates

List mandates details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiListDetokenizedMandatesRequest
*/
func (a *DefaultApiService) ListDetokenizedMandates(ctx context.Context) DefaultApiApiListDetokenizedMandatesRequest {
	return DefaultApiApiListDetokenizedMandatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListMandatesResponse
func (a *DefaultApiService) ListDetokenizedMandatesExecute(r DefaultApiApiListDetokenizedMandatesRequest) (*ListMandatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMandatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListDetokenizedMandates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, "csv"))
	}
	if r.senderType != nil {
		localVarQueryParams.Add("sender_type", parameterToString(*r.senderType, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.institutionId != nil {
		localVarQueryParams.Add("institution_id", parameterToString(*r.institutionId, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiListMandatesRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListMandatesRequest) DateFrom(dateFrom string) DefaultApiApiListMandatesRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListMandatesRequest) DateTo(dateTo string) DefaultApiApiListMandatesRequest {
	r.dateTo = &dateTo
	return r
}

// The mandate statuses to filter for, comma separated
func (r DefaultApiApiListMandatesRequest) Statuses(statuses []string) DefaultApiApiListMandatesRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultApiApiListMandatesRequest) SenderType(senderType string) DefaultApiApiListMandatesRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultApiApiListMandatesRequest) UserId(userId string) DefaultApiApiListMandatesRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultApiApiListMandatesRequest) InstitutionId(institutionId string) DefaultApiApiListMandatesRequest {
	r.institutionId = &institutionId
	return r
}

// default is 0
func (r DefaultApiApiListMandatesRequest) Offset(offset int32) DefaultApiApiListMandatesRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultApiApiListMandatesRequest) Limit(limit int32) DefaultApiApiListMandatesRequest {
	r.limit = &limit
	return r
}

func (r DefaultApiApiListMandatesRequest) Execute() (*ListMandatesResponse, *http.Response, error) {
	return r.ApiService.ListMandatesExecute(r)
}

/*
ListMandates Method for ListMandates

List mandates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiListMandatesRequest
*/
func (a *DefaultApiService) ListMandates(ctx context.Context) DefaultApiApiListMandatesRequest {
	return DefaultApiApiListMandatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListMandatesResponse
func (a *DefaultApiService) ListMandatesExecute(r DefaultApiApiListMandatesRequest) (*ListMandatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMandatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListMandates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mandates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, "csv"))
	}
	if r.senderType != nil {
		localVarQueryParams.Add("sender_type", parameterToString(*r.senderType, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.institutionId != nil {
		localVarQueryParams.Add("institution_id", parameterToString(*r.institutionId, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiListPaymentMethodsRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	paymentUserId string
}

func (r DefaultApiApiListPaymentMethodsRequest) Execute() (*ListPaymentMethodsResponse, *http.Response, error) {
	return r.ApiService.ListPaymentMethodsExecute(r)
}

/*
ListPaymentMethods Method for ListPaymentMethods

List Payment Methods for a User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentUserId Payment User Id
 @return DefaultApiApiListPaymentMethodsRequest
*/
func (a *DefaultApiService) ListPaymentMethods(ctx context.Context, paymentUserId string) DefaultApiApiListPaymentMethodsRequest {
	return DefaultApiApiListPaymentMethodsRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentUserId: paymentUserId,
	}
}

// Execute executes the request
//  @return ListPaymentMethodsResponse
func (a *DefaultApiService) ListPaymentMethodsExecute(r DefaultApiApiListPaymentMethodsRequest) (*ListPaymentMethodsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPaymentMethodsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_users/{paymentUserId}/payment_methods"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentUserId"+"}", url.PathEscape(parameterToString(r.paymentUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiListPaymentsRequest struct {
	ctx           context.Context
	ApiService    DefaultApi
	dateFrom      *string
	dateTo        *string
	statuses      *[]string
	senderType    *string
	userId        *string
	institutionId *string
	paymentType   *string
	paymentTypes  *[]string
	mandateId     *string
	currency      *string
	currencies    *[]string
	offset        *int32
	limit         *int32
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListPaymentsRequest) DateFrom(dateFrom string) DefaultApiApiListPaymentsRequest {
	r.dateFrom = &dateFrom
	return r
}

// ISO format (YYYY-MM-DD)
func (r DefaultApiApiListPaymentsRequest) DateTo(dateTo string) DefaultApiApiListPaymentsRequest {
	r.dateTo = &dateTo
	return r
}

// The payment statuses to filter for, comma separated
func (r DefaultApiApiListPaymentsRequest) Statuses(statuses []string) DefaultApiApiListPaymentsRequest {
	r.statuses = &statuses
	return r
}

// The sender type of the mandate
func (r DefaultApiApiListPaymentsRequest) SenderType(senderType string) DefaultApiApiListPaymentsRequest {
	r.senderType = &senderType
	return r
}

// The user_id the mandate was setup for
func (r DefaultApiApiListPaymentsRequest) UserId(userId string) DefaultApiApiListPaymentsRequest {
	r.userId = &userId
	return r
}

// The institution the mandate was executed against
func (r DefaultApiApiListPaymentsRequest) InstitutionId(institutionId string) DefaultApiApiListPaymentsRequest {
	r.institutionId = &institutionId
	return r
}

// Deprecated - The type of payment
func (r DefaultApiApiListPaymentsRequest) PaymentType(paymentType string) DefaultApiApiListPaymentsRequest {
	r.paymentType = &paymentType
	return r
}
func (r DefaultApiApiListPaymentsRequest) PaymentTypes(paymentTypes []string) DefaultApiApiListPaymentsRequest {
	r.paymentTypes = &paymentTypes
	return r
}

// The mandate the payment belongs to
func (r DefaultApiApiListPaymentsRequest) MandateId(mandateId string) DefaultApiApiListPaymentsRequest {
	r.mandateId = &mandateId
	return r
}

// Deprecated - The currency the payment is made in
func (r DefaultApiApiListPaymentsRequest) Currency(currency string) DefaultApiApiListPaymentsRequest {
	r.currency = &currency
	return r
}
func (r DefaultApiApiListPaymentsRequest) Currencies(currencies []string) DefaultApiApiListPaymentsRequest {
	r.currencies = &currencies
	return r
}

// default is 0
func (r DefaultApiApiListPaymentsRequest) Offset(offset int32) DefaultApiApiListPaymentsRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r DefaultApiApiListPaymentsRequest) Limit(limit int32) DefaultApiApiListPaymentsRequest {
	r.limit = &limit
	return r
}

func (r DefaultApiApiListPaymentsRequest) Execute() (*ListPaymentsResponse, *http.Response, error) {
	return r.ApiService.ListPaymentsExecute(r)
}

/*
ListPayments Method for ListPayments

List Payments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiListPaymentsRequest
*/
func (a *DefaultApiService) ListPayments(ctx context.Context) DefaultApiApiListPaymentsRequest {
	return DefaultApiApiListPaymentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListPaymentsResponse
func (a *DefaultApiService) ListPaymentsExecute(r DefaultApiApiListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPaymentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		localVarQueryParams.Add("date_from", parameterToString(*r.dateFrom, ""))
	}
	if r.dateTo != nil {
		localVarQueryParams.Add("date_to", parameterToString(*r.dateTo, ""))
	}
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, "csv"))
	}
	if r.senderType != nil {
		localVarQueryParams.Add("sender_type", parameterToString(*r.senderType, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.institutionId != nil {
		localVarQueryParams.Add("institution_id", parameterToString(*r.institutionId, ""))
	}
	if r.paymentType != nil {
		localVarQueryParams.Add("payment_type", parameterToString(*r.paymentType, ""))
	}
	if r.paymentTypes != nil {
		localVarQueryParams.Add("payment_types", parameterToString(*r.paymentTypes, "csv"))
	}
	if r.mandateId != nil {
		localVarQueryParams.Add("mandate_id", parameterToString(*r.mandateId, ""))
	}
	if r.currency != nil {
		localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	}
	if r.currencies != nil {
		localVarQueryParams.Add("currencies", parameterToString(*r.currencies, "csv"))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiRefreshPaymentAttemptRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiRefreshPaymentAttemptRequest) Execute() (*RefreshPaymentAttemptResponse, *http.Response, error) {
	return r.ApiService.RefreshPaymentAttemptExecute(r)
}

/*
RefreshPaymentAttempt Method for RefreshPaymentAttempt

Refresh payment attempt from payment link front-end

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiRefreshPaymentAttemptRequest
*/
func (a *DefaultApiService) RefreshPaymentAttempt(ctx context.Context) DefaultApiApiRefreshPaymentAttemptRequest {
	return DefaultApiApiRefreshPaymentAttemptRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return RefreshPaymentAttemptResponse
func (a *DefaultApiService) RefreshPaymentAttemptExecute(r DefaultApiApiRefreshPaymentAttemptRequest) (*RefreshPaymentAttemptResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RefreshPaymentAttemptResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RefreshPaymentAttempt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_attempt/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiSetAutopayConsentRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	setAutopayConsentRequest *SetAutopayConsentRequest
}

func (r DefaultApiApiSetAutopayConsentRequest) SetAutopayConsentRequest(setAutopayConsentRequest SetAutopayConsentRequest) DefaultApiApiSetAutopayConsentRequest {
	r.setAutopayConsentRequest = &setAutopayConsentRequest
	return r
}

func (r DefaultApiApiSetAutopayConsentRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAutopayConsentExecute(r)
}

/*
SetAutopayConsent Method for SetAutopayConsent

Set autopay consent for payment user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiSetAutopayConsentRequest
*/
func (a *DefaultApiService) SetAutopayConsent(ctx context.Context) DefaultApiApiSetAutopayConsentRequest {
	return DefaultApiApiSetAutopayConsentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) SetAutopayConsentExecute(r DefaultApiApiSetAutopayConsentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SetAutopayConsent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment_user/autopay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setAutopayConsentRequest == nil {
		return nil, reportError("setAutopayConsentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setAutopayConsentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiUnlinkPaymentPaymentLinkRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiApiUnlinkPaymentPaymentLinkRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnlinkPaymentPaymentLinkExecute(r)
}

/*
UnlinkPaymentPaymentLink Method for UnlinkPaymentPaymentLink

Unlink payment on payment link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiApiUnlinkPaymentPaymentLinkRequest
*/
func (a *DefaultApiService) UnlinkPaymentPaymentLink(ctx context.Context) DefaultApiApiUnlinkPaymentPaymentLinkRequest {
	return DefaultApiApiUnlinkPaymentPaymentLinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) UnlinkPaymentPaymentLinkExecute(r DefaultApiApiUnlinkPaymentPaymentLinkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UnlinkPaymentPaymentLink")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_link/fvlink/payment/unlink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiUpdatePaymentUserRequest struct {
	ctx                      context.Context
	ApiService               DefaultApi
	paymentUserId            string
	updatePaymentUserRequest *UpdatePaymentUserRequest
}

// request body for updating payment user
func (r DefaultApiApiUpdatePaymentUserRequest) UpdatePaymentUserRequest(updatePaymentUserRequest UpdatePaymentUserRequest) DefaultApiApiUpdatePaymentUserRequest {
	r.updatePaymentUserRequest = &updatePaymentUserRequest
	return r
}

func (r DefaultApiApiUpdatePaymentUserRequest) Execute() (*PaymentUser, *http.Response, error) {
	return r.ApiService.UpdatePaymentUserExecute(r)
}

/*
UpdatePaymentUser Method for UpdatePaymentUser

Update a payment user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentUserId
 @return DefaultApiApiUpdatePaymentUserRequest
*/
func (a *DefaultApiService) UpdatePaymentUser(ctx context.Context, paymentUserId string) DefaultApiApiUpdatePaymentUserRequest {
	return DefaultApiApiUpdatePaymentUserRequest{
		ApiService:    a,
		ctx:           ctx,
		paymentUserId: paymentUserId,
	}
}

// Execute executes the request
//  @return PaymentUser
func (a *DefaultApiService) UpdatePaymentUserExecute(r DefaultApiApiUpdatePaymentUserRequest) (*PaymentUser, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaymentUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdatePaymentUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_users/{paymentUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"paymentUserId"+"}", url.PathEscape(parameterToString(r.paymentUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePaymentUserRequest == nil {
		return localVarReturnValue, nil, reportError("updatePaymentUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePaymentUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrBodyModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
