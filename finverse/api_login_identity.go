/*
Finverse Public

Documentation of the early finverse services

API version: 0.0.1
Contact: info@finverse.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package finverse

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type LoginIdentityApi interface {

	/*
		DeleteLoginIdentity Method for DeleteLoginIdentity

		Delete a specific loginIdentity

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiDeleteLoginIdentityRequest
	*/
	DeleteLoginIdentity(ctx context.Context) LoginIdentityApiApiDeleteLoginIdentityRequest

	// DeleteLoginIdentityExecute executes the request
	//  @return DeleteLoginIdentityResponse
	DeleteLoginIdentityExecute(r LoginIdentityApiApiDeleteLoginIdentityRequest) (*DeleteLoginIdentityResponse, *http.Response, error)

	/*
		GenerateLinkToken Method for GenerateLinkToken

		generate a link token that can be used to create link

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiGenerateLinkTokenRequest
	*/
	GenerateLinkToken(ctx context.Context) LoginIdentityApiApiGenerateLinkTokenRequest

	// GenerateLinkTokenExecute executes the request
	//  @return LinkTokenResponse
	GenerateLinkTokenExecute(r LoginIdentityApiApiGenerateLinkTokenRequest) (*LinkTokenResponse, *http.Response, error)

	/*
		GetAccount Method for GetAccount

		Get a specific account's information

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param accountId The account id
		 @return LoginIdentityApiApiGetAccountRequest
	*/
	GetAccount(ctx context.Context, accountId string) LoginIdentityApiApiGetAccountRequest

	// GetAccountExecute executes the request
	//  @return GetAccountResponse
	GetAccountExecute(r LoginIdentityApiApiGetAccountRequest) (*GetAccountResponse, *http.Response, error)

	/*
		GetAccountNumber Method for GetAccountNumber

		Get the account number for a specific account

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param accountId The account id
		 @return LoginIdentityApiApiGetAccountNumberRequest
	*/
	GetAccountNumber(ctx context.Context, accountId string) LoginIdentityApiApiGetAccountNumberRequest

	// GetAccountNumberExecute executes the request
	//  @return GetAccountNumberResponse
	GetAccountNumberExecute(r LoginIdentityApiApiGetAccountNumberRequest) (*GetAccountNumberResponse, *http.Response, error)

	/*
		GetBalanceHistory Method for GetBalanceHistory

		Get the balance history for a specific account

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param accountId The account id
		 @return LoginIdentityApiApiGetBalanceHistoryRequest
	*/
	GetBalanceHistory(ctx context.Context, accountId string) LoginIdentityApiApiGetBalanceHistoryRequest

	// GetBalanceHistoryExecute executes the request
	//  @return GetBalanceHistoryResponse
	GetBalanceHistoryExecute(r LoginIdentityApiApiGetBalanceHistoryRequest) (*GetBalanceHistoryResponse, *http.Response, error)

	/*
		GetCompositeStatement Method for GetCompositeStatement

		Download composite statement

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiGetCompositeStatementRequest
	*/
	GetCompositeStatement(ctx context.Context) LoginIdentityApiApiGetCompositeStatementRequest

	// GetCompositeStatementExecute executes the request
	//  @return CompositeStatementLink
	GetCompositeStatementExecute(r LoginIdentityApiApiGetCompositeStatementRequest) (*CompositeStatementLink, *http.Response, error)

	/*
		GetIdentity Method for GetIdentity

		\[BETA] Get a list of identity data for a given login identity

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiGetIdentityRequest
	*/
	GetIdentity(ctx context.Context) LoginIdentityApiApiGetIdentityRequest

	// GetIdentityExecute executes the request
	//  @return GetIdentityResponse
	GetIdentityExecute(r LoginIdentityApiApiGetIdentityRequest) (*GetIdentityResponse, *http.Response, error)

	/*
		GetIncomeEstimateByLoginIdentityId Method for GetIncomeEstimateByLoginIdentityId

		Get income figures for a login identity

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest
	*/
	GetIncomeEstimateByLoginIdentityId(ctx context.Context) LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest

	// GetIncomeEstimateByLoginIdentityIdExecute executes the request
	//  @return IncomeResponse
	GetIncomeEstimateByLoginIdentityIdExecute(r LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest) (*IncomeResponse, *http.Response, error)

	/*
		GetLoginIdentity Method for GetLoginIdentity

		Get a specific loginIdentity

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiGetLoginIdentityRequest
	*/
	GetLoginIdentity(ctx context.Context) LoginIdentityApiApiGetLoginIdentityRequest

	// GetLoginIdentityExecute executes the request
	//  @return GetLoginIdentityByIdResponse
	GetLoginIdentityExecute(r LoginIdentityApiApiGetLoginIdentityRequest) (*GetLoginIdentityByIdResponse, *http.Response, error)

	/*
		GetStatement Method for GetStatement

		Download statement

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param statementId The statement id
		 @return LoginIdentityApiApiGetStatementRequest
	*/
	GetStatement(ctx context.Context, statementId string) LoginIdentityApiApiGetStatementRequest

	// GetStatementExecute executes the request
	//  @return GetStatementLinkResponse
	GetStatementExecute(r LoginIdentityApiApiGetStatementRequest) (*GetStatementLinkResponse, *http.Response, error)

	/*
		GetStatements Method for GetStatements

		Get list of available statements

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiGetStatementsRequest
	*/
	GetStatements(ctx context.Context) LoginIdentityApiApiGetStatementsRequest

	// GetStatementsExecute executes the request
	//  @return GetStatementsResponse
	GetStatementsExecute(r LoginIdentityApiApiGetStatementsRequest) (*GetStatementsResponse, *http.Response, error)

	/*
		ListAccounts Method for ListAccounts

		Get a list of accounts for a login identity

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiListAccountsRequest
	*/
	ListAccounts(ctx context.Context) LoginIdentityApiApiListAccountsRequest

	// ListAccountsExecute executes the request
	//  @return ListAccountsResponse
	ListAccountsExecute(r LoginIdentityApiApiListAccountsRequest) (*ListAccountsResponse, *http.Response, error)

	/*
		ListTransactionsByAccountId Method for ListTransactionsByAccountId

		Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
		 @return LoginIdentityApiApiListTransactionsByAccountIdRequest
	*/
	ListTransactionsByAccountId(ctx context.Context, accountId string) LoginIdentityApiApiListTransactionsByAccountIdRequest

	// ListTransactionsByAccountIdExecute executes the request
	//  @return ListTransactionsResponse
	ListTransactionsByAccountIdExecute(r LoginIdentityApiApiListTransactionsByAccountIdRequest) (*ListTransactionsResponse, *http.Response, error)

	/*
		ListTransactionsByLoginIdentityId Method for ListTransactionsByLoginIdentityId

		Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest
	*/
	ListTransactionsByLoginIdentityId(ctx context.Context) LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest

	// ListTransactionsByLoginIdentityIdExecute executes the request
	//  @return ListTransactionsResponse
	ListTransactionsByLoginIdentityIdExecute(r LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest) (*ListTransactionsResponse, *http.Response, error)

	/*
		RefreshLoginIdentity Method for RefreshLoginIdentity

		Create a refresh job for a login identity

		 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return LoginIdentityApiApiRefreshLoginIdentityRequest
	*/
	RefreshLoginIdentity(ctx context.Context) LoginIdentityApiApiRefreshLoginIdentityRequest

	// RefreshLoginIdentityExecute executes the request
	RefreshLoginIdentityExecute(r LoginIdentityApiApiRefreshLoginIdentityRequest) (*http.Response, error)
}

// LoginIdentityApiService LoginIdentityApi service
type LoginIdentityApiService service

type LoginIdentityApiApiDeleteLoginIdentityRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiDeleteLoginIdentityRequest) Execute() (*DeleteLoginIdentityResponse, *http.Response, error) {
	return r.ApiService.DeleteLoginIdentityExecute(r)
}

/*
DeleteLoginIdentity Method for DeleteLoginIdentity

Delete a specific loginIdentity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiDeleteLoginIdentityRequest
*/
func (a *LoginIdentityApiService) DeleteLoginIdentity(ctx context.Context) LoginIdentityApiApiDeleteLoginIdentityRequest {
	return LoginIdentityApiApiDeleteLoginIdentityRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DeleteLoginIdentityResponse
func (a *LoginIdentityApiService) DeleteLoginIdentityExecute(r LoginIdentityApiApiDeleteLoginIdentityRequest) (*DeleteLoginIdentityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteLoginIdentityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.DeleteLoginIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/login_identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGenerateLinkTokenRequest struct {
	ctx              context.Context
	ApiService       LoginIdentityApi
	linkTokenRequest *LinkTokenRequest
}

// token request
func (r LoginIdentityApiApiGenerateLinkTokenRequest) LinkTokenRequest(linkTokenRequest LinkTokenRequest) LoginIdentityApiApiGenerateLinkTokenRequest {
	r.linkTokenRequest = &linkTokenRequest
	return r
}

func (r LoginIdentityApiApiGenerateLinkTokenRequest) Execute() (*LinkTokenResponse, *http.Response, error) {
	return r.ApiService.GenerateLinkTokenExecute(r)
}

/*
GenerateLinkToken Method for GenerateLinkToken

generate a link token that can be used to create link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiGenerateLinkTokenRequest
*/
func (a *LoginIdentityApiService) GenerateLinkToken(ctx context.Context) LoginIdentityApiApiGenerateLinkTokenRequest {
	return LoginIdentityApiApiGenerateLinkTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return LinkTokenResponse
func (a *LoginIdentityApiService) GenerateLinkTokenExecute(r LoginIdentityApiApiGenerateLinkTokenRequest) (*LinkTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinkTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GenerateLinkToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.linkTokenRequest == nil {
		return localVarReturnValue, nil, reportError("linkTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.linkTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetAccountRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
	accountId  string
}

func (r LoginIdentityApiApiGetAccountRequest) Execute() (*GetAccountResponse, *http.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Method for GetAccount

Get a specific account's information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The account id
 @return LoginIdentityApiApiGetAccountRequest
*/
func (a *LoginIdentityApiService) GetAccount(ctx context.Context, accountId string) LoginIdentityApiApiGetAccountRequest {
	return LoginIdentityApiApiGetAccountRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//  @return GetAccountResponse
func (a *LoginIdentityApiService) GetAccountExecute(r LoginIdentityApiApiGetAccountRequest) (*GetAccountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAccountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetAccountNumberRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
	accountId  string
}

func (r LoginIdentityApiApiGetAccountNumberRequest) Execute() (*GetAccountNumberResponse, *http.Response, error) {
	return r.ApiService.GetAccountNumberExecute(r)
}

/*
GetAccountNumber Method for GetAccountNumber

Get the account number for a specific account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The account id
 @return LoginIdentityApiApiGetAccountNumberRequest
*/
func (a *LoginIdentityApiService) GetAccountNumber(ctx context.Context, accountId string) LoginIdentityApiApiGetAccountNumberRequest {
	return LoginIdentityApiApiGetAccountNumberRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//  @return GetAccountNumberResponse
func (a *LoginIdentityApiService) GetAccountNumberExecute(r LoginIdentityApiApiGetAccountNumberRequest) (*GetAccountNumberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAccountNumberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetAccountNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account_numbers/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetBalanceHistoryRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
	accountId  string
	source     *string
}

// The source will determine what type of balance history will be returned
func (r LoginIdentityApiApiGetBalanceHistoryRequest) Source(source string) LoginIdentityApiApiGetBalanceHistoryRequest {
	r.source = &source
	return r
}

func (r LoginIdentityApiApiGetBalanceHistoryRequest) Execute() (*GetBalanceHistoryResponse, *http.Response, error) {
	return r.ApiService.GetBalanceHistoryExecute(r)
}

/*
GetBalanceHistory Method for GetBalanceHistory

Get the balance history for a specific account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The account id
 @return LoginIdentityApiApiGetBalanceHistoryRequest
*/
func (a *LoginIdentityApiService) GetBalanceHistory(ctx context.Context, accountId string) LoginIdentityApiApiGetBalanceHistoryRequest {
	return LoginIdentityApiApiGetBalanceHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//  @return GetBalanceHistoryResponse
func (a *LoginIdentityApiService) GetBalanceHistoryExecute(r LoginIdentityApiApiGetBalanceHistoryRequest) (*GetBalanceHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetBalanceHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetBalanceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/balance_history/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		localVarQueryParams.Add("source", parameterToString(*r.source, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetCompositeStatementRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
	redirect   *bool
}

// when true, response will be http redirect; otherwise it will be json response with the download link
func (r LoginIdentityApiApiGetCompositeStatementRequest) Redirect(redirect bool) LoginIdentityApiApiGetCompositeStatementRequest {
	r.redirect = &redirect
	return r
}

func (r LoginIdentityApiApiGetCompositeStatementRequest) Execute() (*CompositeStatementLink, *http.Response, error) {
	return r.ApiService.GetCompositeStatementExecute(r)
}

/*
GetCompositeStatement Method for GetCompositeStatement

Download composite statement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiGetCompositeStatementRequest
*/
func (a *LoginIdentityApiService) GetCompositeStatement(ctx context.Context) LoginIdentityApiApiGetCompositeStatementRequest {
	return LoginIdentityApiApiGetCompositeStatementRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CompositeStatementLink
func (a *LoginIdentityApiService) GetCompositeStatementExecute(r LoginIdentityApiApiGetCompositeStatementRequest) (*CompositeStatementLink, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompositeStatementLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetCompositeStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/composite_statement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.redirect != nil {
		localVarQueryParams.Add("redirect", parameterToString(*r.redirect, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetIdentityRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiGetIdentityRequest) Execute() (*GetIdentityResponse, *http.Response, error) {
	return r.ApiService.GetIdentityExecute(r)
}

/*
GetIdentity Method for GetIdentity

\[BETA] Get a list of identity data for a given login identity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiGetIdentityRequest
*/
func (a *LoginIdentityApiService) GetIdentity(ctx context.Context) LoginIdentityApiApiGetIdentityRequest {
	return LoginIdentityApiApiGetIdentityRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetIdentityResponse
func (a *LoginIdentityApiService) GetIdentityExecute(r LoginIdentityApiApiGetIdentityRequest) (*GetIdentityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIdentityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest) Execute() (*IncomeResponse, *http.Response, error) {
	return r.ApiService.GetIncomeEstimateByLoginIdentityIdExecute(r)
}

/*
GetIncomeEstimateByLoginIdentityId Method for GetIncomeEstimateByLoginIdentityId

Get income figures for a login identity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest
*/
func (a *LoginIdentityApiService) GetIncomeEstimateByLoginIdentityId(ctx context.Context) LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest {
	return LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return IncomeResponse
func (a *LoginIdentityApiService) GetIncomeEstimateByLoginIdentityIdExecute(r LoginIdentityApiApiGetIncomeEstimateByLoginIdentityIdRequest) (*IncomeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IncomeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetIncomeEstimateByLoginIdentityId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/income"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetLoginIdentityRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiGetLoginIdentityRequest) Execute() (*GetLoginIdentityByIdResponse, *http.Response, error) {
	return r.ApiService.GetLoginIdentityExecute(r)
}

/*
GetLoginIdentity Method for GetLoginIdentity

Get a specific loginIdentity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiGetLoginIdentityRequest
*/
func (a *LoginIdentityApiService) GetLoginIdentity(ctx context.Context) LoginIdentityApiApiGetLoginIdentityRequest {
	return LoginIdentityApiApiGetLoginIdentityRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetLoginIdentityByIdResponse
func (a *LoginIdentityApiService) GetLoginIdentityExecute(r LoginIdentityApiApiGetLoginIdentityRequest) (*GetLoginIdentityByIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetLoginIdentityByIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetLoginIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/login_identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetStatementRequest struct {
	ctx         context.Context
	ApiService  LoginIdentityApi
	statementId string
	redirect    *bool
}

// when true, response will be http redirect; otherwise it will be json response with the download link
func (r LoginIdentityApiApiGetStatementRequest) Redirect(redirect bool) LoginIdentityApiApiGetStatementRequest {
	r.redirect = &redirect
	return r
}

func (r LoginIdentityApiApiGetStatementRequest) Execute() (*GetStatementLinkResponse, *http.Response, error) {
	return r.ApiService.GetStatementExecute(r)
}

/*
GetStatement Method for GetStatement

Download statement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId The statement id
 @return LoginIdentityApiApiGetStatementRequest
*/
func (a *LoginIdentityApiService) GetStatement(ctx context.Context, statementId string) LoginIdentityApiApiGetStatementRequest {
	return LoginIdentityApiApiGetStatementRequest{
		ApiService:  a,
		ctx:         ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return GetStatementLinkResponse
func (a *LoginIdentityApiService) GetStatementExecute(r LoginIdentityApiApiGetStatementRequest) (*GetStatementLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetStatementLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statements/{statementId}"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterToString(r.statementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.redirect != nil {
		localVarQueryParams.Add("redirect", parameterToString(*r.redirect, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiGetStatementsRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiGetStatementsRequest) Execute() (*GetStatementsResponse, *http.Response, error) {
	return r.ApiService.GetStatementsExecute(r)
}

/*
GetStatements Method for GetStatements

Get list of available statements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiGetStatementsRequest
*/
func (a *LoginIdentityApiService) GetStatements(ctx context.Context) LoginIdentityApiApiGetStatementsRequest {
	return LoginIdentityApiApiGetStatementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GetStatementsResponse
func (a *LoginIdentityApiService) GetStatementsExecute(r LoginIdentityApiApiGetStatementsRequest) (*GetStatementsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetStatementsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.GetStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiListAccountsRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiListAccountsRequest) Execute() (*ListAccountsResponse, *http.Response, error) {
	return r.ApiService.ListAccountsExecute(r)
}

/*
ListAccounts Method for ListAccounts

Get a list of accounts for a login identity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiListAccountsRequest
*/
func (a *LoginIdentityApiService) ListAccounts(ctx context.Context) LoginIdentityApiApiListAccountsRequest {
	return LoginIdentityApiApiListAccountsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListAccountsResponse
func (a *LoginIdentityApiService) ListAccountsExecute(r LoginIdentityApiApiListAccountsRequest) (*ListAccountsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListAccountsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.ListAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiListTransactionsByAccountIdRequest struct {
	ctx         context.Context
	ApiService  LoginIdentityApi
	accountId   string
	offset      *int32
	limit       *int32
	enrichments *bool
}

// default is 0
func (r LoginIdentityApiApiListTransactionsByAccountIdRequest) Offset(offset int32) LoginIdentityApiApiListTransactionsByAccountIdRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r LoginIdentityApiApiListTransactionsByAccountIdRequest) Limit(limit int32) LoginIdentityApiApiListTransactionsByAccountIdRequest {
	r.limit = &limit
	return r
}

// when true, response will be enriched transactions; otherwise it will be raw transactions
func (r LoginIdentityApiApiListTransactionsByAccountIdRequest) Enrichments(enrichments bool) LoginIdentityApiApiListTransactionsByAccountIdRequest {
	r.enrichments = &enrichments
	return r
}

func (r LoginIdentityApiApiListTransactionsByAccountIdRequest) Execute() (*ListTransactionsResponse, *http.Response, error) {
	return r.ApiService.ListTransactionsByAccountIdExecute(r)
}

/*
ListTransactionsByAccountId Method for ListTransactionsByAccountId

Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
 @return LoginIdentityApiApiListTransactionsByAccountIdRequest
*/
func (a *LoginIdentityApiService) ListTransactionsByAccountId(ctx context.Context, accountId string) LoginIdentityApiApiListTransactionsByAccountIdRequest {
	return LoginIdentityApiApiListTransactionsByAccountIdRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//  @return ListTransactionsResponse
func (a *LoginIdentityApiService) ListTransactionsByAccountIdExecute(r LoginIdentityApiApiListTransactionsByAccountIdRequest) (*ListTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.ListTransactionsByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.enrichments != nil {
		localVarQueryParams.Add("enrichments", parameterToString(*r.enrichments, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest struct {
	ctx         context.Context
	ApiService  LoginIdentityApi
	offset      *int32
	limit       *int32
	enrichments *bool
}

// default is 0
func (r LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest) Offset(offset int32) LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest {
	r.offset = &offset
	return r
}

// default is 500, max is 1000
func (r LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest) Limit(limit int32) LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest {
	r.limit = &limit
	return r
}

// when true, response will be enriched transactions; otherwise it will be raw transactions
func (r LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest) Enrichments(enrichments bool) LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest {
	r.enrichments = &enrichments
	return r
}

func (r LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest) Execute() (*ListTransactionsResponse, *http.Response, error) {
	return r.ApiService.ListTransactionsByLoginIdentityIdExecute(r)
}

/*
ListTransactionsByLoginIdentityId Method for ListTransactionsByLoginIdentityId

Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest
*/
func (a *LoginIdentityApiService) ListTransactionsByLoginIdentityId(ctx context.Context) LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest {
	return LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListTransactionsResponse
func (a *LoginIdentityApiService) ListTransactionsByLoginIdentityIdExecute(r LoginIdentityApiApiListTransactionsByLoginIdentityIdRequest) (*ListTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.ListTransactionsByLoginIdentityId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.enrichments != nil {
		localVarQueryParams.Add("enrichments", parameterToString(*r.enrichments, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoginIdentityApiApiRefreshLoginIdentityRequest struct {
	ctx        context.Context
	ApiService LoginIdentityApi
}

func (r LoginIdentityApiApiRefreshLoginIdentityRequest) Execute() (*http.Response, error) {
	return r.ApiService.RefreshLoginIdentityExecute(r)
}

/*
RefreshLoginIdentity Method for RefreshLoginIdentity

Create a refresh job for a login identity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LoginIdentityApiApiRefreshLoginIdentityRequest
*/
func (a *LoginIdentityApiService) RefreshLoginIdentity(ctx context.Context) LoginIdentityApiApiRefreshLoginIdentityRequest {
	return LoginIdentityApiApiRefreshLoginIdentityRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *LoginIdentityApiService) RefreshLoginIdentityExecute(r LoginIdentityApiApiRefreshLoginIdentityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoginIdentityApiService.RefreshLoginIdentity")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/login_identity/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BadRequestModelV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
